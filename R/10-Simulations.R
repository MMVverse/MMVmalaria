#' applyCureThreshold
#'
#' @description
#' @param x
#' @param threshold
#' @param PDname Default: 'Parasitemia'
#' @return
#' @export
#' @author Aline Fuchs (MMV)
#' @family Simulations
applyCureThreshold <- function(x, threshold, PDname = "Parasitemia") {
  # Function to switch of regrowth if parasite levels drop below threshold value.
  # Creates a new column in the input data set with modified parasite levels.
  # Mind to have parasite concentrations and given threshold on same scale (linear/log-transformed?)

  # Create new column for modified PD readout
  PDnameNew <- paste0(PDname, "_theo")
  x[[PDnameNew]] <- x[[PDname]]

  # Check whether parasites below threshold
  idxBelow <- x[[PDnameNew]] < threshold
  if (sum(idxBelow) > 0) {
    # Get index of first occasion below threshold
    idxFirst <- min(which(idxBelow))
    # Set all following time points to threshold
    x[[PDnameNew]][idxFirst:dim(x)[1]] <- threshold
  }
  x
}


#' Generate GPF Object from an old IQR project
#'
#' IQRtools evolved since its first implementation, and it is not possible to
#' convert old IQR project to the GPF format using the default IQRtools functions.
#' Therefore, this MMVmalaria function help to generate a GPF object from the summary
#' result table generated by IQRtools. However, the covariance matrix is lost in the process.
#' As well, covariate reference might not be retrieve for the oldest project.
#'
#' @param projectPath IQR project path
#' @param filename Name of the XLS file to save the GPF model is not \code{NULL} (Default: \code{NULL})
#' @param referenceCovariate For the oldest IQR project the referenced covariate can be entered manually. It should be a vector or data frame with the name of the covariate and their reference value: e.g. \code{referenceCovariate = c("WT0"=70, "FORM"=1)} (Default: \code{NULL})
#'
#' @return A GPF object
#'
#' @export
#' @author Mohammed H. Cherkaoui (MMV)
#' @family Simulations
generate_GPFfromOldIQRproject <- function(projectPath,
                                          filename           = NULL,
                                          referenceCovariate = NULL){

  #---------------------------------------------------#
  # STEP 1: Load project result ----
  #---------------------------------------------------#

  # Flag if project result file with attributes exits:
  #   NOTE: - It should exists for IQR projects but not for IQM projects
  #         - Not used yet
  FLAG_ProjRes <- FALSE

  # Read parameters table:
  #   If IQR project
  if(file.exists(file.path(projectPath,"project_parameters_table.txt"))){
    modelResult <- IQRtableToDataFrame(file.path(projectPath,"project_parameters_table.txt"))$dataFrame
    names(modelResult) <- toupper(names(modelResult))
    if (!("COMMENT" %in% names(modelResult))){
      modelResult$COMMENT <- "."
    }

    #   If IQM project
  }else if(file.exists(file.path(projectPath,"parameter_table.txt"))){
    modelResult <- IQRtableToDataFrame(file.path(projectPath,"parameter_table.txt"))$dataFrame
    names(modelResult) <- c("PARAMETER", "VALUE", "RSE", "COMMENT", "SHRINKAGE")

    #   If nothing found
  }else{
    stop("No project file or parameter table present in the project path: ", projectPath)
  }


  #---------------------------------------------------#
  # STEP 2: Load Covariate information ----
  #---------------------------------------------------#

  # Load model information if available:
  modelInfo <- NULL
  #   "New" IQR project file
  if(file.exists(file.path(projectPath,"project.est"))){
    modelInfo <- readRDS(file.path(projectPath,"project.est"))

    #   "Old" IQR project file
  } else if(file.exists(file.path(projectPath,"project.IQRnlmeEst"))){
    # modelInfo <- readRDS(file.path(projectPath,"project.IQRnlmeEst"))
    modelInfo <- source(file.path(projectPath,"project.IQRnlmeEst"))
    modelInfo <- modelInfo[["value"]]

  }

  # Update Reference Covariate:
  if (!is.null(modelInfo)){
    referenceCovariate <- NULL
    if ("COVcentering" %in% names(modelInfo$modelSpec)){
      referenceCovariate <- modelInfo$modelSpec$COVcentering
    }

    # Add what is missing:
    referenceCovariate <- c(referenceCovariate,
                            modelInfo$data$covariateMedianValues)
    referenceCovariate <- referenceCovariate[!duplicated(names(referenceCovariate))]
  }

  #---------------------------------------------------#
  # STEP 3: Get correlation matrix ----
  #---------------------------------------------------#
  unCorFile <- grep("correlationEstimates",list.files(projectPath,recursive = TRUE, full.names = TRUE),value = TRUE)
  unCor <- NULL
  if(length(unCorFile[1])>0){
    # Load correlation matrix
    unCor <- read.delim(unCorFile[1], sep=";", header = FALSE)
    if (ncol(unCor)!=(nrow(unCor)+1)){
      unCor <- read.delim(unCorFile[1], sep = ",", header = FALSE)
    }
  }


  #---------------------------------------------------#
  # STEP 4: Generate the GPF model ----
  #---------------------------------------------------#

  # If result read from project results: (Should give more precise value)
  if (FLAG_ProjRes){
    # TO BE WRITTEN

    # If result loaded from summary result table
  }else{
    modelGPF <- generate_GPFfromParametersTable(parametersTable        = modelResult,
                                                uncertaintyCorrelation = unCor,
                                                filename               = NULL,
                                                referenceCovariate     = referenceCovariate,
                                                modelInfo              = modelInfo)
  }


  #---------------------------------------------------#
  # STEP 5: Output ----
  #---------------------------------------------------#

  # Export to GPF:
  if (!is.null(filename)){
    IQRtools::export_GPF(GPF      = modelGPF,
                         filename = filename)
  }

  # Output:
  return(modelGPF)
}


#' Generate GPF Object from a parameter table
#'
#' Function to be used in `generate_GPFfromOldIQRproject` to geneate a GPF object.
#'
#' @description
#' @param parametersTable IQR/IQM result table
#' @param uncertaintyCorrelation IQR/IQM uncertainty correlation results table
#' @param filename Name of the XLS file to save the GPF model is not \code{NULL} (Default: \code{NULL})
#' @param referenceCovariate For the oldest IQR project the referenced covariate can be entered manually. It should be a vector or data frame with the name of the covariate and their reference value: e.g. \code{referenceCovariate = c("WT0"=70, "FORM"=1)} (Default: \code{NULL})
#' @param modelInfo Model information extracted from `project.est` or `project.IQRnlmeEst` of the IQRproject
#'
#' @return A GPF object
#'
#' @export
#' @author Mohammed H. Cherkaoui (MMV)
#' @family Simulations
generate_GPFfromParametersTable <- function(parametersTable,
                                            uncertaintyCorrelation = NULL,
                                            filename               = NULL,                   # Output path
                                            referenceCovariate     = NULL,
                                            modelInfo              = NULL){

  #---------------------------------------------------#
  # STEP 1: Get the indexes of each parameter type ----
  #---------------------------------------------------#

  # Covariate:
  idx_Beta  <- grepl("beta",parametersTable$PARAMETER)

  # IIV:
  idx_IIV   <- grepl("omega(",parametersTable$PARAMETER, fixed = TRUE)

  # Correlation:
  idx_Corr <- grepl("corr",parametersTable$PARAMETER)

  # Error:
  idx_Error <- grepl("error",parametersTable$PARAMETER)

  # Objective function:
  idx_OBJ   <- (grepl("Objective function",parametersTable$PARAMETER) |
                  grepl("OBJ",parametersTable$PARAMETER) |
                  grepl("BIC",parametersTable$PARAMETER) |
                  grepl("AIC",parametersTable$PARAMETER))

  # Title rows:
  idx_Title <- grepl("**",parametersTable$PARAMETER, fixed = TRUE)

  # Empty row:
  idx_Empty <- parametersTable$PARAMETER==""

  # Parameters:
  idx_Para  <- !(idx_Beta | idx_IIV | idx_Corr | idx_Error | idx_OBJ | idx_Title | idx_Empty)


  #---------------------------------------------------#
  # STEP 2: Transform VALUE and RSE to numeric ----
  #---------------------------------------------------#

  # Value:
  parametersTable$VALUE <- gsub("(FIX)", "", parametersTable$VALUE, fixed = TRUE)
  parametersTable$VALUE <- as.numeric(parametersTable$VALUE)

  # RSE:
  parametersTable$RSE <- gsub("%", "", parametersTable$RSE, fixed = TRUE)
  base::suppressWarnings(
    parametersTable$RSE <- as.numeric(parametersTable$RSE)
  )
  parametersTable$RSE <- ifelse(is.na(parametersTable$RSE), 0, parametersTable$RSE)


  #---------------------------------------------------#
  # STEP 3: Generate table for POP, IIV etc... ----
  #---------------------------------------------------#

  # Pop. Parameter
  parametersTable.POP <- data.frame(PARAMETER         = parametersTable$PARAMETER[idx_Para],
                                    TYPE              = rep("MODEL PARAMETER",nrow(parametersTable))[idx_Para],
                                    VALUE             = parametersTable$VALUE[idx_Para],
                                    VALUE.RSE.PERCENT = parametersTable$RSE[idx_Para],
                                    UNIT              = ifelse(grepl(".*\\((.*)\\)$", parametersTable$COMMENT[idx_Para]),
                                                               gsub(".*\\((.*)\\)$" , "\\1", parametersTable$COMMENT[idx_Para]),
                                                               ""),
                                    NAME              = gsub("\\((.*)\\)$", "", parametersTable$COMMENT[idx_Para]),
                                    stringsAsFactors  = FALSE)

  # IIV Parameter:
  parametersTable.IIV <- data.frame(PARAMETER        = gsub(")", "", gsub("omega(", "", parametersTable$PARAMETER[idx_IIV], fixed = TRUE), fixed = TRUE),
                                    IIV              = parametersTable$VALUE[idx_IIV],
                                    IIV.RSE.PERCENT  = parametersTable$RSE[idx_IIV],
                                    TRANSFORMATION   = parametersTable$COMMENT[idx_IIV],
                                    stringsAsFactors = FALSE)
  # For SYSFIT, no TRANSFORMATION info is written in comments. Get this info from modelSpec
  parameters_noDistInfo <- parametersTable.IIV$PARAMETER[parametersTable.IIV$TRANSFORMATION == "."]
  parameters_noDistInfo <- modelInfo$modelSpec$IIVdistribution[parameters_noDistInfo]
  parametersTable.IIV[parametersTable.IIV$PARAMETER %in% names(parameters_noDistInfo), "TRANSFORMATION"] <- parameters_noDistInfo
  parametersTable.IIV$TRANSFORMATION <- ifelse(tolower(parametersTable.IIV$TRANSFORMATION) %in% c("n", "normal"),
                                               "N",
                                               ifelse(tolower(parametersTable.IIV$TRANSFORMATION) %in% c("l", "lognormal"),
                                                      "L",
                                                      ifelse(tolower(parametersTable.IIV$TRANSFORMATION) %in% c("g", "logitnormal","logit"),
                                                             "G",
                                                             "N")))

  # Covariate:
  parametersTable.Beta <- data.frame(PARAMETER         = parametersTable$PARAMETER[idx_Beta],
                                     TYPE              = rep("COVARIATE",nrow(parametersTable))[idx_Beta],
                                     VALUE             = parametersTable$VALUE[idx_Beta],
                                     VALUE.RSE.PERCENT = parametersTable$RSE[idx_Beta],
                                     UNIT              = rep("-",nrow(parametersTable))[idx_Beta],
                                     NAME              = gsub("\\((.*)\\)$", "", parametersTable$COMMENT[idx_Beta]),
                                     COV.FORMULA       = rep("",nrow(parametersTable))[idx_Beta],
                                     COV.REFERENCE     = rep("",nrow(parametersTable))[idx_Beta],
                                     stringsAsFactors  = FALSE)
  if (nrow(parametersTable.Beta)>0){
    #   Get Parameters and Covariate names
    PARA <- c()
    COV  <- c()
    for (i in 1:nrow(parametersTable.Beta)){
      # Parameter:
      PARA_i <- regmatches(parametersTable.Beta$PARAMETER, regexec('beta_(.*?)\\(', parametersTable.Beta$PARAMETER))[[i]][2]
      PARA   <- c(PARA, PARA_i)

      # Covariate
      COV_i <- regmatches(parametersTable.Beta$PARAMETER, regexec('\\((.*?)\\)'  , parametersTable.Beta$PARAMETER))[[i]][2]
      COV   <- c(COV, COV_i)
    }
    #   Check if continous or categorical
    is.CAT <- grepl("_",COV)
    #   Adjust COV.FORMULA & COV.REFERENCE
    for (i in 1:nrow(parametersTable.Beta)){
      PARA_i <- PARA[i]
      COV_i  <- COV[i]

      # Get Reference value for continuous covariate:
      if (COV_i %in% names(referenceCovariate)){
        referenceCovariate_i <- referenceCovariate[[COV_i]]

      }else if (!is.CAT[i]){
        stop("The reference value of '", COV_i, "' is not provided; Please add it.")
      }

      # Get distribution:
      TRANS_i <- parametersTable.IIV$TRANSFORMATION[parametersTable.IIV$PARAMETER==PARA_i]
      if (length(TRANS_i)==0){
        warning("The distribution of '", PARA_i, "' is missing, and therefore assumed to be normal.")
        TRANS_i <- "N"
      }

      # Construct Formula
      if (is.CAT[i]){
        parametersTable.Beta$TYPE[i] <- "CATEGORICAL COVARIATE"
        if (TRANS_i=="N"){
          parametersTable.Beta$COV.FORMULA[i] <- "X=X_ref+Beta"
        }else if (TRANS_i=="L"){
          parametersTable.Beta$COV.FORMULA[i] <- "X=X_ref*exp(Beta)"
        }else if (TRANS_i=="G"){
          parametersTable.Beta$COV.FORMULA[i] <- "X=X_ref*exp(Beta)/(1-X_ref+X_ref*exp(Beta))"
        }else {
          stop("The distribution of '", PARA_i, "' is not valid: It should be 'N', 'L' or 'G'.")
        }

      }else{
        parametersTable.Beta$TYPE[i] <- "CONTINUOUS COVARIATE"
        if (TRANS_i=="N"){
          parametersTable.Beta$COV.FORMULA[i]   <- paste0("X=X_ref+Beta*log(",COV_i,"/REF)")
          parametersTable.Beta$COV.REFERENCE[i] <- referenceCovariate_i
        }else if (TRANS_i=="L"){
          parametersTable.Beta$COV.FORMULA[i]   <- paste0("X=X_ref*(",COV_i,"/REF)^Beta")
          parametersTable.Beta$COV.REFERENCE[i] <- referenceCovariate_i
        }else if (TRANS_i=="G"){
          parametersTable.Beta$COV.FORMULA[i]   <- paste0("X=X_ref*(",COV_i,"/REF)^Beta/(1-X_ref+X_ref*(",COV_i,"/REF)^Beta)")
          parametersTable.Beta$COV.REFERENCE[i] <- referenceCovariate_i
        }else {
          stop("The distribution of '", PARA_i, "' is not valid: It should be 'N', 'L' or 'G'.")
        }
      }
    }
  }

  # Correlation:
  parametersTable.Corr <- data.frame(PARAMETER         = parametersTable$PARAMETER[idx_Corr],
                                     TYPE              = rep("IIV CORRELATION",nrow(parametersTable))[idx_Corr],
                                     VALUE             = parametersTable$VALUE[idx_Corr],
                                     VALUE.RSE.PERCENT = parametersTable$RSE[idx_Corr],
                                     UNIT              = rep("-",nrow(parametersTable))[idx_Corr],
                                     NAME              = gsub("\\((.*)\\)$", "", parametersTable$COMMENT[idx_Corr]),
                                     COV.FORMULA       = rep("",nrow(parametersTable))[idx_Corr],
                                     COV.REFERENCE     = rep("",nrow(parametersTable))[idx_Corr],
                                     stringsAsFactors  = FALSE)

  # Error:
  parametersTable.Error <- data.frame(PARAMETER         = parametersTable$PARAMETER[idx_Error],
                                      TYPE              = ifelse(grepl("ADD",parametersTable$PARAMETER[idx_Error]),
                                                                 "ADDITIVE ERROR",
                                                                 ifelse(grepl("PROP",parametersTable$PARAMETER[idx_Error]),
                                                                        "RELATIVE ERROR",
                                                                        "ERROR")),
                                      VALUE             = parametersTable$VALUE[idx_Error],
                                      VALUE.RSE.PERCENT = parametersTable$RSE[idx_Error],
                                      UNIT              = ifelse(grepl(".*\\((.*)\\)$", parametersTable$COMMENT[idx_Error]),
                                                                 gsub(".*\\((.*)\\)$" , "\\1", parametersTable$COMMENT[idx_Error]),
                                                                 ""),
                                      NAME              = gsub("\\((.*)\\)$", "", parametersTable$COMMENT[idx_Error]),
                                      TRANSFORMATION    = rep("-",nrow(parametersTable))[idx_Error],
                                      stringsAsFactors  = FALSE)


  #---------------------------------------------------#
  # STEP 4: Generate correlation matrix into GPF format ----
  #---------------------------------------------------#
  if(!is.null(uncertaintyCorrelation)){
    # Get Name:
    unCorName <- as.character(uncertaintyCorrelation[,1])
    unCorName <- gsub(" ","", unCorName)
    #   Manage pop. para. name:
    unCorName <- gsub("_pop","",unCorName)
    #   Manage IIV name
    idx_Omega <- grepl("omega_", unCorName)
    unCorName[idx_Omega] <- paste0(gsub("omega_","omega(",unCorName[idx_Omega]),")")
    #   Manage additive error Name:
    aName <- c("a", paste0("a",1:100))
    if(any(unCorName %in% aName)){
      aValue <- ifelse(aName=="a","a1",aName)
      aValue <- as.numeric(gsub("a","",aValue))
      idx_ADD <- which(unCorName %in% aName)
      unCorName[idx_ADD] <- paste0("error_ADD",aValue[match(unCorName,aName,nomatch = NULL)][idx_ADD])
    }
    #   Manage proportional error Name:
    bName <- c("b", paste0("b",1:100))
    if(any(unCorName %in% bName)){
      bValue <- ifelse(bName=="b","b1",bName)
      bValue <- as.numeric(gsub("b","",bValue))
      idx_PROP <- which(unCorName %in% bName)
      unCorName[idx_PROP] <- paste0("error_PROP",bValue[match(unCorName,bName,nomatch = NULL)][idx_PROP])
    }
    #   Manage Beta name:
    idx_Beta <- grepl("beta_", unCorName)
    if(length(which(idx_Beta))>0){
      pos_Beta <- gregexpr(pattern ="_",unCorName[idx_Beta])
      unCorName[idx_Beta] <- sapply(1:length(pos_Beta), function(k){
        out <- unCorName[idx_Beta][k]
        substr(out, pos_Beta[[k]][2], pos_Beta[[k]][2]) <- "("
        out
      })
    }
    unCorName[idx_Beta] <- paste0(unCorName[idx_Beta],")")
    #   Manage correlation name
    idx_COR <- grepl("corr_", unCorName)
    unCorName[idx_COR] <- gsub("corr_", "corr(", unCorName[idx_COR])
    unCorName[idx_COR] <- gsub("_"    , ","  , unCorName[idx_COR])
    unCorName[idx_COR] <- paste0(unCorName[idx_COR],")")

    # Adjust correlation matrix:
    uncertaintyCorrelation <- as.matrix(uncertaintyCorrelation[,2:ncol(uncertaintyCorrelation)])
    uncertaintyCorrelation <- ifelse(is.nan(uncertaintyCorrelation),0,uncertaintyCorrelation)
    uncertaintyCorrelation[upper.tri(uncertaintyCorrelation)] <- NA
    diag(uncertaintyCorrelation) <- 1

    # Add names:
    rownames(uncertaintyCorrelation) <- unCorName
    colnames(uncertaintyCorrelation) <- unCorName
    uncertaintyCorrelation <- data.table::as.data.table(uncertaintyCorrelation, keep.rownames = "PARAMETER")
  }

  #---------------------------------------------------#
  # STEP 5: Generate table to export into GPF ----
  #---------------------------------------------------#

  # Table:
  modelGPF <- dplyr::bind_rows(dplyr::bind_rows(dplyr::bind_rows(dplyr::left_join(parametersTable.POP,
                                                                                  parametersTable.IIV),
                                                                 parametersTable.Beta),
                                                parametersTable.Corr),
                               parametersTable.Error)
  modelGPF <- within(modelGPF,{
    VALUE.RSE.PERCENT <- ifelse(is.na(VALUE.RSE.PERCENT), 0 , VALUE.RSE.PERCENT)
    IIV               <- ifelse(is.na(IIV)              , 0 , IIV)
    IIV.RSE.PERCENT   <- ifelse(is.na(IIV.RSE.PERCENT)  , 0 , IIV.RSE.PERCENT)
    TRANSFORMATION    <- ifelse(is.na(TRANSFORMATION)   , "", TRANSFORMATION)
    COV.FORMULA       <- ifelse(is.na(COV.FORMULA)      , "", COV.FORMULA)
    COV.REFERENCE     <- ifelse(is.na(COV.REFERENCE)    , "", COV.REFERENCE)
    COMMENT           <- NA
  })

  # Convert to GPF object:
  base::suppressWarnings(
    modelGPF <- IQRtools::GPF(estimates = modelGPF, uncertainty_correlation = uncertaintyCorrelation)
  )

  # Export to GPF:
  if (!is.null(filename)){
    IQRtools::export_GPF(GPF      = modelGPF,
                         filename = filename)
  }

  # Output:
  return(modelGPF)
}


#' generateTrialSim
#'
#' @description
#' @param modelFolder
#' @param data
#' @param NTRIALS
#' @param covariateDose Default: \code{NULL}
#' @return
#' @export
#' @author Aline Fuchs (MMV)
#' @family Simulations
#' @importFrom plyr ddply
#' @importFrom parallel mclapply
#' @importFrom dplyr left_join
generateTrialSim <- function(
  modelFolder,
  data,
  NTRIALS,
  covariateDose = NULL
) {
  # TO DO:
  # - regression parameters
  # - handle T= negative
  # - multiple doses working properly?
  # - handle occacions/cohorts (eg fasted/fed condition)

  ###########################################################################-
  ## Get model and model results
  ###########################################################################-

  modelResults <- getResults_IQRnlmeProjectMulti(as_IQRnlmeProjectMulti(modelFolder))[[1]]

  # Load model
  model <- IQRmodel(paste0(modelFolder,"/model.txt"))

  ###########################################################################-
  ## Dataset for VPC
  ###########################################################################-

  data <- data

  ###########################################################################-
  ## Get covariates in the considered model
  ###########################################################################-

  # Covariates
  covariates <- modelResults$projectHeader$COVARIATESUSED
  if ("" %in% covariates) {
    covariate_information <- NULL
  } else {
    covariate_information <- unique(data[,c('ID','STUDYN',covariates)])
  }


  ###########################################################################-
  ## Get SIMTIME
  ###########################################################################-

  SIMTIME <- sort(unique(data$NT))

  ###########################################################################-
  ## Generate dosing scheme
  ###########################################################################-
  dosing <- unique(data[data$TYPENAME == "Dose", c("ID", "STUDYN", "TRTNAME", "TIME", "AMT", "ADM", "II", "ADDL", "ROUTE", "TINF", "RATE")])
  amtInfo <- plyr::ddply(dosing, ~ID, function(x) x[order(x$TIME),][1, c("ID", "AMT")])

  # Remove the dosing interval and additional doses column if they are all NA
  if (all(is.na(dosing$II))) dosing$II <- NULL
  if (all(is.na(dosing$ADDL))) dosing$ADDL <- NULL

  # Check whether all dosing columns are well defined
  for (colk in c("ADM", "II", "ADDL", "ROUTE", "TINF", "RATE")) {
    if (any(is.na(dosing[[colk]]))) warning(paste0("\n  -- There are NAs in dosing records for ", colk, "! --\n"))
  }

  ###########################################################################-
  ## Get residual error estimates
  ###########################################################################-

  ResidualError <- list()
  for (k in seq_along(modelResults$projectHeader$ERRORMODELS)) {
    if (modelResults$projectHeader$ERRORMODELS[k] == "rel") {
      ResidualError[[paste0("OUTPUT", k)]] <- c(
        abs = 0,
        rel = modelResults$parametervalues[modelResults$parameternames == paste0("error_PROP", k)])
    }
    if (modelResults$projectHeader$ERRORMODELS[k] == "abs") {
      ResidualError[[paste0("OUTPUT", k)]] <- c(
        abs = modelResults$parametervalues[modelResults$parameternames == paste0("error_ADD", k)],
        rel = 0)
    }
    if (modelResults$projectHeader$ERRORMODELS[k] == "absrel") {
      ResidualError[[paste0("OUTPUT", k)]] <- c(
        abs = modelResults$parametervalues[modelResults$parameternames == paste0("error_ADD", k)],
        rel = modelResults$parametervalues[modelResults$parameternames == paste0("error_PROP", k)])
    }
  }


  ###########################################################################-
  ## Simulate VPC
  ###########################################################################-

  NSUBJECTS <- length(unique(data$ID))

  ncores = 24
  if (.Platform$OS.type=="windows") {
    ncores = 1
  }

  xxx <- parallel::mclapply(1:NTRIALS, mc.cores=ncores, mc.preschedule = FALSE, FUN=function (k) {
    print(k)

    # Sample NSUBJECTS covariates from the dataset if covariates in the model
    if (!is.null(covariate_information)) {
      covariate_samples <- covariate_information[sample(nrow(covariate_information), NSUBJECTS), ]
      # If one of the covariates is dose this needs to be set to the amount
      if (!is.null(covariateDose)){
        covariate_samples[[covariateDose]] <- amtInfo$AMT
      }
    } else {
      covariate_samples <- NULL
    }

    # Sample NSUBJECTS individual parameters (including uncertainty distribution)
    param <- sample_IQRnlmeProject(modelFolder,FLAG_SAMPLE=1,Nsamples=NSUBJECTS,covariates=covariate_samples)$parameterValuesIndividual
    param$ID <- 1:NSUBJECTS

    # Generate EventTable
    eventData <- dplyr::left_join(dosing, param)
    if (modelResults$projectHeader$DOSINGTYPES == "ABSORPTION0")
      eventData$TINF <- eventData$Tk0

    eventTable <- IQReventTable(
      data = eventData,
      regression = setdiff(names(param), c("ID", "Tk0"))
    )

    # Simulate
    simres <- sim_IQRmodel(model,simtime=SIMTIME,eventTable=eventTable,FLAGsensitivity=FALSE,FLAGoutputsOnly=TRUE)

    # Add noise
    for (k in seq_along(ResidualError))
      simres[[paste0("OUTPUT", k)]] <- abs(simres[[paste0("OUTPUT", k)]] +
                                             (ResidualError[[paste0("OUTPUT", k)]][1]+ResidualError[[paste0("OUTPUT", k)]][2]*simres[[paste0("OUTPUT", k)]])*rnorm(nrow(simres)))

    # Add treatment information
    simres <- dplyr::left_join(simres, unique(dosing[, c("ID", "TRTNAME")]))
    x <- plyr::ddply(simres, ~TIME+TRTNAME, function(xx) {
      yy <- data.frame(
        q05 = quantile(xx$OUTPUT1, 0.05),
        q50 = quantile(xx$OUTPUT1, 0.5),
        q95 = quantile(xx$OUTPUT1, 0.95)
      )
    })

    # Collect results
    list(x)
  })

  xxx_ALL <- do.call(rbind, lapply(xxx, function(yyy) yyy[[1]]))


  ###########################################################################-
  ## Create simulation plot data
  ###########################################################################-

  yy <- plyr::ddply(xxx_ALL, ~TIME+TRTNAME, function(xx) {
    y <- data.frame(
      lower.q05 = quantile(xx$q05, 0.025),
      upper.q05 = quantile(xx$q05, 0.975),
      lower.q50 = quantile(xx$q50, 0.025),
      upper.q50 = quantile(xx$q50, 0.975),
      lower.q95 = quantile(xx$q95, 0.025),
      upper.q95 = quantile(xx$q95, 0.975)
    )
  })
  dataSim <- reshape(yy, direction = "long",
                     idvar = c("TIME", "TRTNAME"),
                     varying = setdiff(names(yy), c("TIME", "TRTNAME")),
                     timevar = "TYPE")

  dataSim$TYPE <- factor(dataSim$TYPE, levels=c("q05","q50","q95"), labels=c("5th Percentile","Median","95th Percentile"))

  dataSim
}


#' Get Model Parameters from a GPF/XLS file
#'
#' Load into a list the the population, IIV, Betas and residual parameters, each formatted into a data.frame from
#' a CSV file. Used in [getModelParameters_MMVmalariaProject].
#'
#' @param filename A character string with the path to a CSV file with all parameters.
#'
#' @return A list with the population, IIV, Betas and residual parameters, each formatted into a data.frame.
#'
#' @author Mohammed H. Cherkaoui (MMV)
#' @family Simulations
getModelParameters_MMVmalariaCSV <- function(filename){

  #---------------------------------------------------#
  # STEP 1: Load CSV file ----
  #---------------------------------------------------#
  parametersModel <- IQRloadCSVdata(filename = filename)

  # Check if new format:
  if ("VALUE.RSE.PERCENT" %in% names(parametersModel)){
    return(getModelParameters_MMVmalariaXLS(filename = filename))
  }


  #---------------------------------------------------#
  # STEP 2: Get model parameters ----
  #---------------------------------------------------#

  # Get parameters Names:
  if ("PARAMETER" %in% names(parametersModel)){
    parameters.NAMES <- parametersModel$PARAMETER
  }else{
    stop("Column 'PARAMETER' is missing: Please adjust the CSV file.")
  }

  # Identify model, covariate and error parameters:
  idx_Beta <- grepl("beta_" , parameters.NAMES)
  idx_Err  <- grepl("error_", parameters.NAMES)
  idx_Cor  <- grepl("cor_"  , parameters.NAMES)
  idx_Para <- !(idx_Beta | idx_Err)

  # Get population parameters values:
  if ("VALUE" %in% names(parametersModel)){
    parameters.POP <- parametersModel$VALUE[idx_Para]
    names(parameters.POP) <- parameters.NAMES[idx_Para]
  }else{
    stop("Column 'VALUE' is missing: Please adjust the CSV file.")
  }

  # Get IIV if relevent:
  if ("IIV" %in% names(parametersModel)){
    parameters.IIV <- parametersModel$IIV[idx_Para]
    names(parameters.IIV) <- parameters.NAMES[idx_Para]
  }else{
    parameters.IIV <- NULL
  }

  # Get distribution if relevent:
  if ("DIST" %in% names(parametersModel)){
    parameters.DIST <- parametersModel$DIST[idx_Para]
    names(parameters.DIST) <- parameters.NAMES[idx_Para]
  }else{
    parameters.DIST <- NULL
  }

  # Get RSE of value if relevent:
  if ("VALUE.RSE" %in% names(parametersModel)){
    parameters.POP.RSE <- parametersModel$VALUE.RSE[idx_Para]
    names(parameters.POP.RSE) <- parameters.NAMES[idx_Para]
  }else{
    parameters.POP.RSE <- NULL
  }

  # Get RSE of IIV if relevent:
  if ("IIV.RSE" %in% names(parametersModel)){
    parameters.IIV.RSE <- parametersModel$IIV.RSE[idx_Para]
    names(parameters.IIV.RSE) <- parameters.NAMES[idx_Para]
  }else{
    parameters.IIV.RSE <- NULL
  }

  # Organise as table:
  Parameters <- data.frame(NAME      = parameters.NAMES[idx_Para],
                           VALUE     = parameters.POP,
                           VALUE.RSE = parameters.POP.RSE,
                           IIV       = parameters.IIV,
                           IIV.RSE   = parameters.IIV.RSE,
                           DIST      = parameters.DIST,
                           stringsAsFactors = FALSE)

  #---------------------------------------------------#
  # STEP 3: Get covariate information ----
  #---------------------------------------------------#
  Beta <- NULL
  if (length(which(idx_Beta))!=0){
    # Get Parameters-Covariate Name, Value and Formula:
    Beta <- data.frame(NAME      = parameters.NAMES[idx_Beta],
                       VALUE     = parametersModel$VALUE[idx_Beta],
                       VALUE.RSE = 0,
                       DIST      = "N",
                       FORMULA   = parametersModel$FORMULA[idx_Beta],
                       stringsAsFactors = FALSE)

    # Adjust VALUE.RSE:
    if ("VALUE.RSE" %in% names(parametersModel)){
      Beta$VALUE.RSE <- parametersModel$VALUE.RSE[idx_Beta]
    }

    # Adjust DIST:
    if ("DIST" %in% names(parametersModel)){
      Beta$DIST <- parametersModel$DIST[idx_Beta]
    }

    # Detect:
    #   - Which parameter should be adjusted
    PARAMETER <- c()
    Para_temp <- regmatches(Beta$NAME, regexec('beta_(.*?)\\(', Beta$NAME))
    #   - Which covariate should be use
    COVARIATE <- c()
    Cov_temp  <- regmatches(Beta$NAME, regexec('\\((.*?)\\)'  , Beta$NAME))
    #   - If continuous covariate
    cov0      <- c()
    #   - If categorical covariate, what is the correspondent value of the covariate.
    catN      <- c()
    #   - Loop over the number of Beta values
    for (i in 1:nrow(Beta)){

      # Get Parameter name:
      PARAMETER_i <- Para_temp[[i]][2]


      # Get Covariate name:
      COVARIATE_i <- Cov_temp[[i]][2]

      # Detect if continuous:
      cov0_i    <- !grepl("_",COVARIATE_i)

      # If categorical, which is the value assosiated to it
      catN_i <- NA
      if (!cov0_i){
        cat_Split_i <- strsplit(COVARIATE_i, "_")
        catN_i      <- as.numeric(cat_Split_i[[1]][2])
        COVARIATE_i <- cat_Split_i[[1]][1]
      }

      # Concatenate:
      PARAMETER <- c(PARAMETER, PARAMETER_i)
      COVARIATE <- c(COVARIATE, COVARIATE_i)
      cov0      <- c(cov0     , cov0_i)
      catN      <- c(catN     , catN_i)
    }

    # Add thos information to Beta:
    Beta <- within(Beta,{
      catN      <- catN
      cov0      <- cov0
      COVARIATE <- COVARIATE
      PARAMETER <- PARAMETER
    })
  }

  #---------------------------------------------------#
  # STEP 4: IIV Correlation Parameters ----
  #---------------------------------------------------#
  IIVcorrelation <- NULL
  if (length(which(idx_Cor))!=0){
    IIVcorrelation <- data.frame(NAME     = parameters.NAMES[idx_Cor],
                                 VALUE     = parametersModel$VALUE[idx_Cor],
                                 VALUE.RSE = 0,
                                 stringsAsFactors = FALSE)

    # Adjust VALUE.RSE:
    if ("VALUE.RSE" %in% names(parametersModel)){
      IIVcorrelation$VALUE.RSE <- parametersModel$VALUE.RSE[idx_Cor]
    }

  }


  #---------------------------------------------------#
  # STEP 5: Error Parameters ----
  #---------------------------------------------------#
  ResidualError <- NULL
  if (length(which(idx_Err))!=0){
    ResidualError <- data.frame(NAME      = parameters.NAMES[idx_Err],
                                VALUE     = parametersModel$VALUE[idx_Err],
                                VALUE.RSE = parametersModel$VALUE.RSE[idx_Err],
                                stringsAsFactors = FALSE)

    # Adjust VALUE.RSE:
    if ("VALUE.RSE" %in% names(parametersModel)){
      ResidualError$VALUE.RSE <- parametersModel$VALUE.RSE[idx_Err]
    }

  }

  #---------------------------------------------------#
  # STEP 6: Generate Output ----
  #---------------------------------------------------#

  # Save into list:
  modelParameters <- list(Parameters     = Parameters,
                          Beta           = Beta,
                          IIVcorrelation = IIVcorrelation,
                          ResidualError  = ResidualError)

  # Output:
  return(modelParameters)
}

#' Get Model Parameters from a GPF/XLS file
#'
#' Load into a list the the population, IIV, Betas and residual parameters, each formatted into a data.frame from
#' a GPF/XLS file. Used in [getModelParameters_MMVmalariaProject].
#'
#' @param filename A character string with the path to a GPF file.
#'
#' @return A list with the population, IIV, Betas and residual parameters, each formatted into a data.frame.
#'
#' @author Mohammed H. Cherkaoui (MMV)
#' @family Simulations
getModelParameters_MMVmalariaXLS <- function(filename){

  #---------------------------------------------------#
  # STEP 1: Load XLS file ----
  #---------------------------------------------------#
  parametersModel <- load_GPF(filename)


  #---------------------------------------------------#
  # STEP 2: Get Population parameters ----
  #---------------------------------------------------#

  # Identify model, covariate and error parameters:
  idx_Para <- grepl("MODEL PARAMETER", parametersModel$estimates$TYPE)
  idx_Beta <- grepl("COVARIATE"      , parametersModel$estimates$TYPE)
  idx_Cor  <- grepl("CORRELATION"    , parametersModel$estimates$TYPE)
  idx_Err  <- grepl("ERROR"          , parametersModel$estimates$TYPE)

  # Organise as table:
  Parameters <- data.frame(NAME      = parametersModel$estimates$PARAMETER[idx_Para],
                           VALUE     = parametersModel$estimates$VALUE[idx_Para],
                           VALUE.RSE = parametersModel$estimates$VALUE.RSE.PERCENT[idx_Para]/100,
                           IIV       = parametersModel$estimates$IIV[idx_Para],
                           IIV.RSE   = parametersModel$estimates$IIV.RSE.PERCENT[idx_Para]/100,
                           DIST      = parametersModel$estimates$TRANSFORMATION[idx_Para],
                           stringsAsFactors = FALSE)


  #---------------------------------------------------#
  # STEP 3: Get covariate information ----
  #---------------------------------------------------#
  Beta <- NULL
  if (length(which(idx_Beta))!=0){
    # Get Parameters-Covariate Name, Value and Formula:
    Beta <- data.frame(NAME          = parametersModel$estimates$PARAMETER[idx_Beta],
                       VALUE         = parametersModel$estimates$VALUE[idx_Beta],
                       VALUE.RSE     = parametersModel$estimates$VALUE.RSE.PERCENT[idx_Beta]/100,
                       DIST          = parametersModel$estimates$TRANSFORMATION[idx_Beta],
                       COV.FORMULA   = parametersModel$estimates$COV.FORMULA[idx_Beta],
                       COV.REFERENCE = parametersModel$estimates$COV.REFERENCE[idx_Beta],
                       stringsAsFactors = FALSE)

    # Detect:
    #   - Which parameter should be adjusted
    PARAMETER <- c()
    Para_temp <- regmatches(Beta$NAME, regexec('beta_(.*?)\\(', Beta$NAME))
    #   - Which covariate should be use
    COVARIATE <- c()
    Cov_temp  <- regmatches(Beta$NAME, regexec('\\((.*?)\\)'  , Beta$NAME))
    #   - If continuous covariate
    cov0      <- c()
    #   - If categorical covariate, what is the correspondent value of the covariate.
    catN      <- c()
    #   - Loop over the number of Beta values
    for (i in 1:nrow(Beta)){

      # Get Parameter name:
      PARAMETER_i <- Para_temp[[i]][2]

      # Get Covariate name:
      COVARIATE_i <- Cov_temp[[i]][2]

      # Detect if continuous:
      cov0_i    <- !grepl("_",COVARIATE_i)

      # If categorical, which is the value assosiated to it
      catN_i <- NA
      if (!cov0_i){
        cat_Split_i <- strsplit(COVARIATE_i, "_")
        catN_i      <- as.numeric(cat_Split_i[[1]][2])
        COVARIATE_i <- cat_Split_i[[1]][1]
      }

      # Concatenate:
      PARAMETER <- c(PARAMETER, PARAMETER_i)
      COVARIATE <- c(COVARIATE, COVARIATE_i)
      cov0      <- c(cov0     , cov0_i)
      catN      <- c(catN     , catN_i)
    }

    # Add those information to Beta:
    Beta <- within(Beta,{
      catN      <- catN
      cov0      <- cov0
      COVARIATE <- COVARIATE
      PARAMETER <- PARAMETER
    })
  }

  #---------------------------------------------------#
  # STEP 4: IIV Correlation Parameters ----
  #---------------------------------------------------#
  IIVcorrelation <- NULL
  if (length(which(idx_Err))!=0){
    ResidualError <- data.frame(NAME      = parametersModel$estimates$PARAMETER[idx_Err],
                                VALUE     = parametersModel$estimates$VALUE[idx_Err],
                                VALUE.RSE = parametersModel$estimates$VALUE.RSE.PERCENT[idx_Err]/100,
                                stringsAsFactors = FALSE)

  }


  #---------------------------------------------------#
  # STEP 5: Error Parameters ----
  #---------------------------------------------------#
  ResidualError <- NULL
  if (length(which(idx_Err))!=0){
    ResidualError <- data.frame(NAME      = parametersModel$estimates$PARAMETER[idx_Err],
                                VALUE     = parametersModel$estimates$VALUE[idx_Err],
                                VALUE.RSE = parametersModel$estimates$VALUE.RSE.PERCENT[idx_Err]/100,
                                stringsAsFactors = FALSE)

  }

  #---------------------------------------------------#
  # STEP 6: Generate Output ----
  #---------------------------------------------------#

  # Save into list:
  modelParameters <- list(Parameters     = Parameters,
                          Beta           = Beta,
                          IIVcorrelation = IIVcorrelation,
                          ResidualError  = ResidualError)

  # Output:
  return(modelParameters)
}

#' Get Model Parameters from a MMVmalaria Project
#'
#' Load into a list the the population, IIV, Betas and residual parameters, each formatted into a data.frame from
#' a MMVmalaria Project. This is useful to prepare a ModelSpec object as in [modelSpec_MMVmalariaProject].
#'
#' @param projectPath A character string with the path to an IQRsysProject or IQRnlmeProject folder, or a GPF file.
#'
#' @return A list with the population, IIV, Betas and residual parameters, each formatted into a data.frame.
#'
#' @export
#'
#' @author Mohammed H. Cherkaoui (MMV)
#' @family Simulations
getModelParameters_MMVmalariaProject <- function(projectPath){
  # From a NLME or sysFIT project:
  if (is.character(projectPath)){
    if (is_IQRsysProject(projectPath)){
      # It should work as the IQRsysProject will be converted to a GPF object automatically:
      out <- getModelParameters_MMVmalariaXLS(filename = projectPath)

    }else if(is_IQRnlmeProject(projectPath)){
      # It should work as the IQRnlmeProject will be converted to a GPF object automatically:
      out <- getModelParameters_MMVmalariaXLS(filename = projectPath)

    }else if((tolower(get_fileNameExtension(projectPath))=="csv") && is.fileMMV(projectPath)){
      out <- getModelParameters_MMVmalariaCSV(filename = projectPath)

    }else if((tolower(get_fileNameExtension(projectPath)) %in% c("xls", "xlsx")) && is.fileMMV(projectPath)){
      out <- getModelParameters_MMVmalariaXLS(filename = projectPath)

    }else{
      stop("If '", projectPath, "' is a path, it is neither a valid CSV/XLS file, IQRsysProject nor IQRnlmeProject.")
    }


  }else{
    stop("'projectPath' is neither a valid IQRsysProject, IQRnlmeProject.")
  }

  # Output:
  return(out)
}


#' getPopParameters_MMVmalariaCSV
#'
#' @description
#' @param filename
#' @param IndCovariates Default: \code{NULL}
#' @return
#' @export
#' @author Mohammed H. Cherkaoui (MMV)
#' @family Simulations
getPopParameters_MMVmalariaCSV <- function(filename,                  # Path to a CSV file
                                           IndCovariates = NULL){

  #---------------------------------------------------#
  # STEP 1: Get model parameters ----
  #---------------------------------------------------#

  if (is.null(IndCovariates)){
    base::suppressWarnings(Sample <- sample_MMVmalariaCSV(filename = filename,
                                                          Nsamples = 2,
                                                          FLAG_SAMPLE = 0))
  }else{
    base::suppressWarnings(Sample <- sample_MMVmalariaCSV(filename = filename,
                                                          Nsamples = dim(IndCovariates)[1],
                                                          FLAG_SAMPLE = 3,
                                                          covariates  = IndCovariates))
  }

  #---------------------------------------------------#
  # STEP 2: Output ----
  #---------------------------------------------------#
  out <- Sample$typicalIndParamValues
  return(out)
}




#' getPopParameters_MMVmalariaXLS
#'
#' @description
#' @param filename
#' @param IndCovariates Default: \code{NULL}
#' @return
#' @export
#' @author Mohammed H. Cherkaoui (MMV)
#' @family Simulations
getPopParameters_MMVmalariaXLS <- function(filename,                  # Path to a CSV file
                                           IndCovariates = NULL){

  #---------------------------------------------------#
  # STEP 1: Get model parameters ----
  #---------------------------------------------------#

  if (is.null(IndCovariates)){
    Sample <- sample_MMVmalariaXLS(filename = filename,
                                   Nsamples = 1,
                                   FLAG_SAMPLE = 0,
                                   covariates  = NULL)
  }else{
    Sample <- sample_MMVmalariaXLS(filename = filename,
                                   Nsamples = dim(IndCovariates)[1],
                                   FLAG_SAMPLE = 3,
                                   covariates  = IndCovariates)
  }


  #---------------------------------------------------#
  # STEP 2: Output ----
  #---------------------------------------------------#
  out <- Sample$typicalIndParamValues
  return(out)
}


#' getPopParameters_MMVmalariaProject
#'
#' @description
#' @param projectPath
#' @param IndCovariates Default: \code{NULL}
#' @param verbose Default: TRUE
#' @return
#' @export
#' @author Mohammed H. Cherkaoui (MMV)
#' @family Simulations
getPopParameters_MMVmalariaProject <- function(projectPath,
                                               IndCovariates = NULL,
                                               verbose       = TRUE) {

  # From a NLME or sysFIT project:
  if (is.character(projectPath)){
    if (exists("is_IQRsysProject", mode="function") && is_IQRsysProject(projectPath)){

      out <- getPopParameters_IQRnlmeProject(projectPath   = projectPath,
                                             IndCovariates = IndCovariates,
                                             verbose       = verbose)

      if (is.null(IndCovariates)){
        out <- as.data.frame(t(out))
      }


    }else if(is_IQRnlmeProject(projectPath)){
      out <- getPopParameters_IQRnlmeProject(projectPath   = projectPath,
                                             IndCovariates = IndCovariates,
                                             verbose       = verbose)

      if (is.null(IndCovariates)){
        out <- as.data.frame(t(out))
      }

    }else if((tolower(get_fileNameExtension(projectPath))=="csv") && is.fileMMV(projectPath)){
      out <- getPopParameters_MMVmalariaCSV(filename = projectPath,       # Path to a CSV file
                                            IndCovariates = IndCovariates)

    }else if((tolower(get_fileNameExtension(projectPath)) %in% c("xls", "xlsx")) && is.fileMMV(projectPath)){
      out <- getPopParameters_MMVmalariaXLS(filename = projectPath,       # Path to a XLS file
                                            IndCovariates = IndCovariates)

    }else{
      stop("If '", projectPath, "' is a path, it is neither a valid CSV/XLS file, IQRsysProject nor IQRnlmeProject.")
    }

    # From a customized function
  }else if(is.function(projectPath)){
    # Sample from function:
    if (!is.null(IndCovariates) && ("covariates" %in% methods::formalArgs(projectPath)) && ("FLAG_SAMPLE" %in% formalArgs(projectPath))){
      out <- projectPath(nrow(IndCovariates),
                         covariates  = IndCovariates,
                         FLAG_SAMPLE = 3)

    }else if (!is.null(IndCovariates) && ("covariates" %in% methods::formalArgs(projectPath))){
      out <- projectPath(nrow(IndCovariates),
                         covariates = IndCovariates)

    }else if ("FLAG_SAMPLE" %in% methods::formalArgs(projectPath)){
      out <- projectPath(1,
                         FLAG_SAMPLE = 0)

    }else{
      out <- projectPath(1)
    }

    # Check if list or data.frame:
    if (is.data.frame(out)){
      out <- NULL
      warning("'projectPath' is a function that does not return a list with 'popParamValues', 'typicalIndParamValues' and 'indParamValues', therfore no population parameters are associated to the project.")
      # # Adjust number of row if needed:
      # if (!is.null(IndCovariates) && nrow(out)==1){
      #   out <- out[rep(seq_len(nrow(out)), each = nrow(IndCovariates)), ]
      #   rownames(out) <- NULL
      # }

    }else if (is.list(out)){
      if (!("popParamValues" %in% names(out)) || !("typicalIndParamValues" %in% names(out)) || !("indParamValues" %in% names(out))){
        stop("The function 'projectPath' returns a list that does not contain 'popParamValues', 'typicalIndParamValues' and/or 'indParamValues': please adjust")
      }

      # Keep only population parameters:
      out <- out$typicalIndParamValues

    }else{
      stop("The function 'projectPath' should return a list of dataframe or a dataframe.")
    }


  }else{
    stop("'projectPath' is neither a valid IQRsysProject, IQRnlmeProject nor sampling function.")
  }


  # Output:
  return(out)
}


#' predict_HumanChallenge
#'
#' @description
#' @param PKeventTable
#' @param PDmodelFolder
#' @param data
#' @param GRhuman Default: \code{NULL}
#' @param model Default: \code{NULL}
#' @param CureThreshold Default: log(1/5000)
#' @return
#' @export
#' @author Mohammed H. Cherkaoui (MMV)
#' @family Simulations
#' @importFrom plyr ddply
predict_HumanChallenge <- function(
  PKeventTable,
  PDmodelFolder,
  data,
  GRhuman       = NULL,
  model         = NULL,
  CureThreshold = log(1/5000) # log transformed p/mL
) {

  # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # PD model with SCID parameters and GRhuman

  # Get PKPD model:
  if (is.null(model)){
    model <- IQRmodel(file.path(PDmodelFolder,"model.txt"))
  }

  # Get PD parameters:
  PDparameters <- getPopParameters_IQRnlmeProject(PDmodelFolder)
  captionPlus  <- " - Growth Rate SCID"
  if (!is.null(GRhuman)){
    PDparameters[["GR"]] <- GRhuman
    captionPlus <- " - Growth Rate Modified"
  }


  # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # Simulation

  # Simulation time:
  simTime <- union(seq(0, max(data$TIME, na.rm = TRUE), 0.5), unique(data$TIME[data$TIME >= 0]))
  simTime <- simTime[order(simTime)]

  # Simulations:
  res <- sim_IQRmodel(model, simtime = simTime, eventTable = PKeventTable, parameters = PDparameters)

  # Apply cure threshold:
  res <- plyr::ddply(res, ~ID, function(x) {
    idxX <- x$OUTPUT1 < CureThreshold
    if (any(idxX)) {
      x$OUTPUT1[which(idxX)[1]:length(idxX)] <- CureThreshold
    }
    x
  })


  # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # Visualize
  dataPD <- subset(data, TYPENAME == "Efficacy" & MDV == 0)
  LLOQ   <- unique(dataPD$LLOQ)
  xmin   <- min(dataPD$TIME)
  gr <- IQRggplot(res, aes(TIME, OUTPUT1, group = ID)) +
    geom_hline(yintercept=LLOQ, linetype = 3) +
    geom_text(x=xmin,y=LLOQ, label="LLOQ", size = 3, hjust=0, vjust= -0.2) +
    geom_line() +
    geom_point(data = dataPD, aes(y=VALUE)) +
    geom_line(data = dataPD, aes(y=VALUE), linetype = 2, color = "grey") +
    facet_wrap(~ID) +
    scale_x_continuous(breaks = seq(-48*5,1000,48)) +
    labs(x       = "Time [hours]",
         y       = "Parasitemia [log p/mL]",
         #title   = "",
         caption = paste0("GR=", PDparameters[["GR"]], captionPlus)) +
    theme(#legend.position  = "bottom",
      #legend.direction = "vertical",
      #legend.text      = element_text(size=6),
      #legend.title     = element_text(size = 8),
      plot.caption     = element_text(hjust=0))


  # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # Output
  list(simPKPD   = res,
       IQRggplot = gr)
}


#' sample_CustomParameters
#'
#' @description
#' @param parameters.POP
#' @param parameters.IIV
#' @param parameters.IIVcor
#' @param parameters.DIST
#' @param Nsamples
#'
#' @return
#'
#' @author Mohammed H. Cherkaoui (MMV)
#' @family Simulations
sample_CustomParameters <- function(parameters.POP,
                                    parameters.IIV,
                                    parameters.IIVcor = NULL,
                                    parameters.DIST,
                                    Nsamples) {

  #---------------------------------------------------#
  # STEP 1: Setting prior sampling ----
  #---------------------------------------------------#

  # Unlist if necessary:
  parameters.POP     <- unlist(parameters.POP)
  parameters.IIV     <- unlist(parameters.IIV)
  parameters.IIVcor  <- unlist(parameters.IIVcor)
  parameters.DIST    <- unlist(parameters.DIST)

  # Number of parameters:
  nPara <- length(parameters.POP)

  # Create dataset for Individual Parameters:
  parameters.INDIV           <- data.frame(matrix(NA, nrow = Nsamples, ncol = nPara))
  colnames(parameters.INDIV) <- names(parameters.POP)

  #---------------------------------------------------#
  # STEP 2: Sampling  of POP and IIV parameters ----
  #---------------------------------------------------#

  # Index of the different distribution:
  idx_norm    <- which(parameters.DIST=="N")
  idx_lognorm <- which(parameters.DIST=="L")
  idx_logit   <- which(parameters.DIST=="G")

  # Test if the distribution entered are correct:
  if (length(union(idx_norm,union(idx_lognorm,idx_logit)))==0){
    stop("parameters.DIST should be a vector containing 'N', 'L' or 'G', representing normal, log-normal and Logit distribution, respectively.")
  }
  if (length(union(idx_norm,union(idx_lognorm,idx_logit)))!=nPara){
    stop("parameters.DIST should be a vector containing 'N', 'L' or 'G', representing normal, log-normal and Logit distribution, respectively.")
  }

  if (is.null(parameters.IIVcor) | length(parameters.IIVcor) == 0) {
    # -> There is not correlations of IIVs, univariate sampling ok
    # Sampling:
    for (k in 1:Nsamples){
      # Drawing of the normal distributions:
      epsilon <- rnorm(nPara)

      # Normal Distribution:
      parameters.INDIV[k,idx_norm] <- parameters.POP[idx_norm] + parameters.IIV[idx_norm]*epsilon[idx_norm]

      # Log-Normal Distribution:
      parameters.INDIV[k,idx_lognorm] <- parameters.POP[idx_lognorm]*exp(parameters.IIV[idx_lognorm]*epsilon[idx_lognorm])

      # Logit Distribution:
      parameters.INDIV[k,idx_logit] <- parameters.POP[idx_logit]*exp(parameters.IIV[idx_logit]*epsilon[idx_logit])/(1+parameters.POP[idx_logit]*(exp(parameters.IIV[idx_logit]*epsilon[idx_logit])-1))
    }
  } else {
    # -> Sample individual parameters from covariance matrix

    # Construnct covariance matrix of IIVs
    #. first the correlation matrix
    IIVcorrelation <- diag(rep(1,length(parameters.IIV)))
    dimnames(IIVcorrelation) <- list(names(parameters.IIV),names(parameters.IIV))
    for (k in seq_along(parameters.IIVcor)) {
      tmp <- getCorrParNames(names(parameters.IIVcor)[k])
      par1 <- tmp[1]; idx1 <- names(parameters.IIV) == par1
      par2 <- tmp[2]; idx2 <- names(parameters.IIV) == par2
      IIVcorrelation[idx1,idx2] <-  parameters.IIVcor[k]
      IIVcorrelation[idx2,idx1] <-  parameters.IIVcor[k]
    }
    # . convert to covariance
    # IIVcovariance <- sweep(sweep(IIVcorrelation, 1, parameters.IIV, "*"), 2, parameters.IIV, "*")
    IIVcovariance <- diag(parameters.IIV) %*% IIVcorrelation %*% diag(parameters.IIV)

    for (k in 1:Nsamples){
      # Drawing of the multivariate normal distributions:
      epsilon <- MASS::mvrnorm(1, mu = rep(0, nPara), Sigma = IIVcovariance)

      # Venelin Mitov (30.04.2020): The following code has a bug (there should be no multiplication of
      #
      # epsilon with parameters.IIV, since this is already taken into account in the IIVcovariance matrix).
      # # Normal Distribution:
      # parameters.INDIV[k,idx_norm] <- parameters.POP[idx_norm] + parameters.IIV[idx_norm]*epsilon[idx_norm]
      #
      # # Log-Normal Distribution:
      # parameters.INDIV[k,idx_lognorm] <- parameters.POP[idx_lognorm]*exp(parameters.IIV[idx_lognorm]*epsilon[idx_lognorm])
      #
      # # Logit Distribution:
      # parameters.INDIV[k,idx_logit] <- parameters.POP[idx_logit]*exp(parameters.IIV[idx_logit]*epsilon[idx_logit])/(1+parameters.POP[idx_logit]*(exp(parameters.IIV[idx_logit]*epsilon[idx_logit])-1))


      # Normal Distribution:
      parameters.INDIV[k,idx_norm] <- parameters.POP[idx_norm] + epsilon[idx_norm]

      # Log-Normal Distribution:
      parameters.INDIV[k,idx_lognorm] <- parameters.POP[idx_lognorm]*exp(epsilon[idx_lognorm])

      # Logit Distribution:
      parameters.INDIV[k,idx_logit] <- parameters.POP[idx_logit]*exp(epsilon[idx_logit])/(1+parameters.POP[idx_logit]*(exp(epsilon[idx_logit])-1))

    }

  }

  #---------------------------------------------------#
  # STEP 3: Generate output ----
  #---------------------------------------------------#
  return(parameters.INDIV)
}


#' sample_MMVmalariaXLS
#'
#' @description
#' @param filename
#' @param Nsamples
#' @param FLAG_SAMPLE Default: 0
#' @param covariates Default: \code{NULL}
#' @param FLAGid Default: FALSE
#'
#' @return
#'
#' @author Venelin Mitov (IntiQuan)
#' @family Simulations
sample_MMVmalariaXLS <- function(filename,                  # Path to a XLS file
                                 Nsamples,
                                 FLAG_SAMPLE = 0,
                                 covariates  = NULL,    # Data Frame
                                 FLAGid      = FALSE){

  # Check FLAG_SAMPLE:
  if(!(FLAG_SAMPLE %in% 0:8)){
    stop("'FLAG_SAMPLE' should be an integer between 0 and 8: Please adjust.")
  }else if(FLAG_SAMPLE==7){
    FLAG_SAMPLE <- 0
  }else if(FLAG_SAMPLE==8){
    FLAG_SAMPLE <- 1
  }

  # Sample:
  res <- IQRtools::sampleIndParamValues(spec = filename,
                                        data = covariates,
                                        Nsamples = Nsamples,
                                        FLAG_SAMPLE = FLAG_SAMPLE)

  # Get Parameters Names:
  #   To be inline with current IQRtools sampling function
  parameterNames <- names(res$popParamValues)
  parameterNames <- setdiff(parameterNames, c("ID.POP", "ID"))
  parameterNames <- parameterNames[!grepl("omega(", parameterNames, fixed=TRUE)]
  parameterNames <- parameterNames[!grepl("beta_" , parameterNames, fixed=TRUE)]
  parameterNames <- parameterNames[!grepl("corr(" , parameterNames, fixed=TRUE)]
  parameterNames <- parameterNames[!grepl("error_", parameterNames, fixed=TRUE)]

  # Remove Unwanted columns:
  if(!is.null(res$popParamValues)){
    res$popParamValues <- res$popParamValues[,parameterNames, drop = FALSE]
  }
  if(!is.null(res$typicalIndParamValues)){
    res$typicalIndParamValues <- res$typicalIndParamValues[,parameterNames, drop = FALSE]
  }
  if(!is.null(res$indParamValues)){
    res$indParamValues <- res$indParamValues[,parameterNames, drop = FALSE]
  }

  # Keep only object of interest:
  #   NOTE: - To be similar to sample_IQRnlmeProjet.
  #         - Could evolve in the future
  res <- res[intersect(c("FLAG_SAMPLE", "Nsamples",
                         "popParamValues",
                         "typicalIndParamValues",
                         "indParamValues"),
                       names(res))]

  # Output:
  return(res)
}


#' sample_MMVmalariaCSV
#'
#' @description
#' @param filename
#' @param Nsamples
#' @param FLAG_SAMPLE Default: 0
#' @param covariates Default: \code{NULL}
#' @param FLAGid Default: FALSE
#'
#' @return
#'
#' @author Mohammed H. Cherkaoui (MMV)
#' @family Simulations
sample_MMVmalariaCSV <- function(filename,                  # Path to a CSV file
                                 Nsamples,
                                 FLAG_SAMPLE     = 0,
                                 covariates      = NULL,    # Data Frame
                                 FLAGid          = FALSE){

  # Load column name of the CSV file:
  colNamesCSV <- names(IQRloadCSVdata(filename = filename))

  # Check column name to decide which function to call:
  if("VALUE.RSE" %in% colNamesCSV){
    out <- sample_MMVmalariaCSV_OLD(filename    = filename,
                                    Nsamples    = Nsamples,
                                    FLAG_SAMPLE = FLAG_SAMPLE,
                                    covariates  = covariates,
                                    FLAGid      = FLAGid)
  }else if("VALUE.RSE.PERCENT" %in% colNamesCSV){
    out <- sample_MMVmalariaCSV_NEW(filename    = filename,
                                    Nsamples    = Nsamples,
                                    FLAG_SAMPLE = FLAG_SAMPLE,
                                    covariates  = covariates,
                                    FLAGid      = FLAGid)
  }else{
    stop("The column names of the CSV model are not valid.")
  }

  # Output:
  return(out)
}


#' sample_MMVmalariaCSV_NEW
#'
#' @description
#' @param filename
#' @param Nsamples
#' @param FLAG_SAMPLE Default: 0
#' @param covariates Default: \code{NULL}
#' @param FLAGid Default: FALSE
#'
#' @return
#'
#' @author Venelin Mitov (IntiQuan)
#' @family Simulations
sample_MMVmalariaCSV_NEW <- function(filename,                  # Path to a XLS file
                                     Nsamples,
                                     FLAG_SAMPLE = 0,
                                     covariates  = NULL,    # Data Frame
                                     FLAGid      = FALSE) {

  sample_MMVmalariaXLS(filename    = filename,
                       Nsamples    = Nsamples,
                       FLAG_SAMPLE = FLAG_SAMPLE,
                       covariates  = covariates,
                       FLAGid      = FLAGid)
}


#' sample_MMVmalariaProject
#'
#' @description
#' @param projectPath
#' @param Nsamples Default: \code{NULL}
#' @param FLAG_SAMPLE Default: 0
#' @param covariates Default: \code{NULL}
#' @param FLAGid Default: FALSE
#' @param verbose Default: TRUE
#'
#' @return
#'
#' @export
#'
#' @author Mohammed H. Cherkaoui (MMV)
#' @family Simulations
sample_MMVmalariaProject <- function(projectPath,
                                     Nsamples     = NULL,
                                     FLAG_SAMPLE  = 0,
                                     covariates   = NULL,
                                     FLAGid       = FALSE,
                                     verbose      = TRUE) {

  #-------------------------------------------------------------------------#
  # STEP 1: Select appropriate sampling function ----
  #-------------------------------------------------------------------------#
  if (is.character(projectPath)){
    if (is_IQRsysProject(projectPath)){
      out <- sample_IQRnlmeProject(input       = projectPath,
                                   Nsamples    = Nsamples,
                                   FLAG_SAMPLE = FLAG_SAMPLE,
                                   covariates  = covariates,
                                   FLAGid      = FLAGid,
                                   verbose     = verbose)

    }else if(is_IQRnlmeProject(projectPath)){
      out <- sample_IQRnlmeProject(input       = projectPath,
                                   Nsamples    = Nsamples,
                                   FLAG_SAMPLE = FLAG_SAMPLE,
                                   covariates  = covariates,
                                   FLAGid      = FLAGid,
                                   verbose     = verbose)

    }else if ((tolower(get_fileNameExtension(projectPath)) %in% c("csv")) && is.fileMMV(projectPath)){
      out <- sample_MMVmalariaCSV(filename    = projectPath,
                                  Nsamples    = Nsamples,
                                  FLAG_SAMPLE = FLAG_SAMPLE,
                                  covariates  = covariates,
                                  FLAGid      = FLAGid)

    }else if ((tolower(get_fileNameExtension(projectPath)) %in% c("xls","xlsx")) && is.fileMMV(projectPath)){
      out <- sample_MMVmalariaXLS(filename    = projectPath,
                                  Nsamples    = Nsamples,
                                  FLAG_SAMPLE = FLAG_SAMPLE,
                                  covariates  = covariates,
                                  FLAGid      = FLAGid)

    }else{
      stop("If '", projectPath, "' is a path, it is neither a valid IQRsysProject, an IQRnlmeProject nor a CSV/XLS/XLSX file.")
    }

  }else if(is.function(projectPath)){
    # Sample from function:
    if (("covariates" %in% methods::formalArgs(projectPath)) && ("FLAG_SAMPLE" %in% methods::formalArgs(projectPath))){
      out <- projectPath(Nsamples,
                         covariates  = covariates,
                         FLAG_SAMPLE = FLAG_SAMPLE)

    }else if ("covariates" %in% methods::formalArgs(projectPath)){
      out <- projectPath(Nsamples,
                         covariates = covariates)

    }else if ("FLAG_SAMPLE" %in% methods::formalArgs(projectPath)){
      out <- projectPath(Nsamples,
                         FLAG_SAMPLE = FLAG_SAMPLE)

    }else{
      out <- projectPath(Nsamples)
    }

    # Check if list or data.frame:
    if (is.data.frame(out)){
      out_temp <- out
      out      <- list(FLAG_SAMPLE = FLAG_SAMPLE,
                       Nsamples    = Nsamples,
                       popParamValues        = out_temp,
                       typicalIndParamValues = out_temp,
                       indParamValues        = out_temp)

    }else if (is.list(out)){
      if (!("parameterValuesPopulation" %in% names(out)) || !("parameterValuesIndividual" %in% names(out))){
        stop("The function 'projectPath' returns a list that does not contain 'parameterValuesIndividual' and/or 'parameterValuesIndividual'; please adjust")
      }

    }else{
      stop("The function 'projectPath' should return a list of dataframe or a dataframe.")
    }


  }else{
    stop("'projectPath' is neither a valid IQRsysProject, an IQRnlmeProject, a CSV file nor sampling function.")
  }


  #-------------------------------------------------------------------------#
  # STEP 2: Output ----
  #-------------------------------------------------------------------------#
  return(out)
}

#' simTimeRecrudescenceCombo
#' Simulate combo model for a grid of dose-combinations
#'
#' This function is helpful for isobole plots.
#' Simulate combo model for all combinations of doses of drug 1 and 2.
#' Then compute time to recrudescence for
#'
#' @param model IQRmodel
#' @param parameters Named vector of parameters
#' @param doses1,doses2 Vectors of doses. Each combination of both will be simulated
#' @param n1,n2 Number doses per drug, administration is assumed to be every 24h.
#' @param LLOQ LLOQ of model OUTPUT1
#' @param simlength Default: 24 * 32. maximum simtime
#' @param setting Default: \code{NULL}. Named list of arguments going to \code{\link[IQRtools]{sim_IQRmodel}}
#' @return data.frame with colums c("ID", "Time2Recrud", "n1", "n2", "Dose1", "Dose2")
#' @export
#' @author Anne K?mmel (IntiQuan), Mohammed Cherkaoui (MMV)
#' @family Simulations
#' @importFrom plyr ddply join
simTimeRecrudescenceCombo <- function(model, parameters,
                                      doses1, doses2, n1, n2,
                                      LLOQ, simlength = 24*32,
                                      setting = NULL)
{
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # Define default solver setting ----
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  # Flags & Sensitivity Parameters to Test:
  if ("FLAGsensitivity" %in% names(setting)){FLAGsensitivity = setting$FLAGsensitivity} else{FLAGsensitivity = FALSE}
  if ("FLAGuseSensEq"   %in% names(setting)){FLAGuseSensEq   = setting$FLAGuseSensEq  } else{FLAGuseSensEq   = TRUE }
  if ("sensParams"      %in% names(setting)){sensParams      = setting$sensParams     } else{sensParams      = NULL }
  if ("FLAGoutputsOnly" %in% names(setting)){FLAGoutputsOnly = setting$FLAGoutputsOnly} else{FLAGoutputsOnly = TRUE }

  # Sensitivity Parameters to Test:
  if ("opt_eventTimes"            %in% names(setting)){opt_eventTimes            = setting$opt_eventTimes           } else{opt_eventTimes            = NULL }
  if ("opt_method_stiff"          %in% names(setting)){opt_method_stiff          = setting$opt_method_stiff         } else{opt_method_stiff          = TRUE }
  if ("opt_abstol"                %in% names(setting)){opt_abstol                = setting$opt_abstol               } else{opt_abstol                = 1e-09}
  if ("opt_reltol"                %in% names(setting)){opt_reltol                = setting$opt_reltol               } else{opt_reltol                = 1e-06}
  if ("opt_minstep"               %in% names(setting)){opt_minstep               = setting$opt_minstep              } else{opt_minstep               = 0    }
  if ("opt_maxstep"               %in% names(setting)){opt_maxstep               = setting$opt_maxstep              } else{opt_maxstep               = 0    }
  if ("opt_initstep"              %in% names(setting)){opt_initstep              = setting$opt_initstep             } else{opt_initstep              = 0    }
  if ("opt_maxnumsteps"           %in% names(setting)){opt_maxnumsteps           = setting$opt_maxnumsteps          } else{opt_maxnumsteps           = 1e+05}
  if ("opt_maxerrtestfails"       %in% names(setting)){opt_maxerrtestfails       = setting$opt_maxerrtestfails      } else{opt_maxerrtestfails       = 50   }
  if ("opt_maxorder_stiff"        %in% names(setting)){opt_maxorder_stiff        = setting$opt_maxorder_stiff       } else{opt_maxorder_stiff        = 5    }
  if ("opt_maxorder_nonstiff"     %in% names(setting)){opt_maxorder_nonstiff     = setting$opt_maxorder_nonstiff    } else{opt_maxorder_nonstiff     = 12   }
  if ("opt_maxconvfails"          %in% names(setting)){opt_maxconvfails          = setting$opt_maxconvfails         } else{opt_maxconvfails          = 10   }
  if ("opt_maxnonlineariter"      %in% names(setting)){opt_maxnonlineariter      = setting$opt_maxnonlineariter     } else{opt_maxnonlineariter      = 3    }
  if ("opt_usesymjac"             %in% names(setting)){opt_usesymjac             = setting$opt_usesymjac            } else{opt_usesymjac             = TRUE }
  if ("opt_sens_simultaneous"     %in% names(setting)){opt_sens_simultaneous     = setting$opt_sens_simultaneous    } else{opt_sens_simultaneous     = FALSE}
  if ("opt_sens_errcon"           %in% names(setting)){opt_sens_errcon           = setting$opt_sens_errcon          } else{opt_sens_errcon           = FALSE}
  if ("opt_sens_maxnonlineariter" %in% names(setting)){opt_sens_maxnonlineariter = setting$opt_sens_maxnonlineariter} else{opt_sens_maxnonlineariter = 3    }

  # Verbose:
  if ("verbose" %in% names(setting)){verbose = setting$verbose } else{verbose = FALSE}

  # Time2Rec:
  if ("Time2RecDef" %in% names(setting)){Time2RecDef = setting$Time2RecDef } else{Time2RecDef = "MMV"}


  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # Core's Function ----
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  # Initializazion
  lfd=0
  dosing  <- data.frame()
  dosInfo <- data.frame()

  # Check inputs
  # No zero number of dose allowed
  if (n1 == 0 | n2 == 0) stop("Number of doses for combination simulation of recrudescence time not allowed t0 be 0.")

  # Create all dose combinations to test
  for (k1 in 1:length(doses1))
  {
    for (k2 in 1:length(doses2))
    {
      lfd <- lfd+1

      # Adjust dosing
      dosk <- data.frame(ID   = lfd,
                         TIME = c(seq(0,by=24, length.out=n1),seq(0,by=24, length.out=n2)),
                         ADM  = c(rep(1,n1),rep(2,n2)),
                         AMT  = c(rep(doses1[k1],n1), rep(doses2[k2],n2)))

      # ID information
      dosInfo <- rbind(dosInfo, data.frame(ID = lfd, n1=n1, n2=n2, Dose1=doses1[k1], Dose2=doses2[k2]))

      # Collect dosing
      dosing <- rbind(dosing, dosk)
    }
  }

  # create event table
  regressionPars <- intersect(names(parameters), names(model$parameters)) # determine regression parameters (keep only the ones that appear in the model)
  eventTable <- IQReventTable(cbind(dosing, as.data.frame(t(parameters))), regression = regressionPars)

  # Simulate
  cat("\nSimulate 2D panel")
  simres <- sim_IQRmodel(model,
                         simtime                   = seq(0,simlength, by = 1),
                         eventTable                = eventTable,
                         FLAGsensitivity           = FLAGsensitivity,
                         FLAGuseSensEq             = FLAGuseSensEq,
                         sensParams                = sensParams,
                         FLAGoutputsOnly           = FLAGoutputsOnly,
                         opt_eventTimes            = opt_eventTimes,
                         opt_method_stiff          = opt_method_stiff,
                         opt_abstol                = opt_abstol,
                         opt_reltol                = opt_reltol,
                         opt_minstep               = opt_minstep,
                         opt_maxstep               = opt_maxstep,
                         opt_initstep              = opt_initstep,
                         opt_maxnumsteps           = opt_maxnumsteps,
                         opt_maxerrtestfails       = opt_maxerrtestfails,
                         opt_maxorder_stiff        = opt_maxorder_stiff,
                         opt_maxorder_nonstiff     = opt_maxorder_nonstiff,
                         opt_maxconvfails          = opt_maxconvfails,
                         opt_maxnonlineariter      = opt_maxnonlineariter,
                         opt_usesymjac             = opt_usesymjac,
                         opt_sens_simultaneous     = opt_sens_simultaneous,
                         opt_sens_errcon           = opt_sens_errcon,
                         opt_sens_maxnonlineariter = opt_sens_maxnonlineariter,
                         verbose                   = verbose)
  cat("  ... finished!\n")

  # Get time to recrudescence
  res0 <- plyr::ddply(simres, ~ID,
                      function(x) {
                        if (Time2RecDef=="MMV"){
                          if (min(x$OUTPUT1)>LLOQ){
                            # case parasites not below LLOQ:
                            # time to recrudescence as time at parasitemia nadir
                            Time2Recrud <- x$TIME[which.min(x$OUTPUT1)]
                          } else {
                            # case parasites are below LLOQ for some time:
                            # time to recrudescence as first timepoint after being below LLOQ or the maximum simulation time
                            idxRecrud   <- min(max(which(x$OUTPUT1 < LLOQ))+1, length(x$TIME))
                            Time2Recrud <- x$TIME[idxRecrud]
                          }


                        }else if (Time2RecDef=="TAD"){
                          # Get idx if minimum parasitemia
                          idx_MIN <- which.min(x$OUTPUT1)

                          # If the initial parasitemia is the minimum => Time2Rec=0
                          if (idx_MIN==1){
                            Time2Recrud <- 0

                            # If the final parasitemia is the minimum => Time2Rec=NULL
                          }else if (idx_MIN==length(x$OUTPUT1)){
                            Time2Recrud <- NULL

                            # Otherwise estimate:
                          }else{
                            # Get the maximum index of parasitemia just below baseline:
                            idx_TAD <- max(which(x$OUTPUT1<x$OUTPUT1[1]))

                            # Get growth rate:
                            GR <- unique(parameters[["GR"]])

                            # Estimat Time2Rec by linear regression:
                            Time2Recrud <- x$TIME[idx_TAD] + (x$OUTPUT1[1] - x$OUTPUT1[idx_TAD])/GR
                          }


                        }else{
                          stop("'Time2RecDef' should be equal to 'MMV' or 'TAD'.")
                        }

                        # Return:
                        out <- data.frame(Time2Recrud=Time2Recrud)
                      })

  # Get dosing information
  res0 <- plyr::join(res0, dosInfo)

  # Output
  res0
}

#' simulate_ComboMouse2Human
#'
#' @description
#' @param TreatmentGroups
#' @param PKmodelFolders
#' @param PDmodelFolders
#' @param InteractionModelFolder
#' @param ComboModel
#' @param PbaseSample Default: function(x) {
#'    sample_Distribution(Mean = 10^6.72, SD = 0.1, Dist = "L",
#'        nSample = x)
#'}
#' @param GRsample Default: function(x) {
#'    sample_Distribution(Mean = 0.048, SD = 0.1, Dist = "L", nSample = x)
#'}
#' @param doseCovariate Default: list(drug1 = NULL, drug2 = NULL)
#' @param covariates Default: \code{NULL}
#' @param evalDay Default: 28
#' @param simtime Default: create_PKPDsimtime(24 * evalDay)
#' @param nTrial Default: 10
#' @param nSubj Default: 10
#' @param LLOQ.PD
#' @param cureThreshold
#' @param replace Default: TRUE
#' @param setting Default: \code{NULL}
#' @return
#' @export
#' @author Anne Kümmel (IntiQuan), Mohammed H. Cherkaoui (MMV)
#' @family Simulations
#' @importFrom plyr ddply
#' @importFrom tidyr gather
#' @importFrom dplyr left_join
simulate_ComboMouse2Human <- function(TreatmentGroups,
                                      PKmodelFolders,
                                      PDmodelFolders,
                                      InteractionModelFolder,
                                      ComboModel,
                                      PbaseSample   = function(x){sample_Distribution(Mean    = 10^6.72,
                                                                                      SD      = 0.1,
                                                                                      Dist    = "L",
                                                                                      nSample = x)},    # Function or vector with baseline values to sample from (linear scale)
                                      GRsample      = function(x){sample_Distribution(Mean    = 0.048,
                                                                                      SD      = 0.1,
                                                                                      Dist    = "L",
                                                                                      nSample = x)},    # Function or vector with growth rate values to sample from
                                      doseCovariate = list(drug1 = NULL, drug2 = NULL),  # indicate name for the dose covariate
                                      covariates    = NULL,     # Named list of covariate vectors to sample from
                                      evalDay       = 28,
                                      simtime       = create_PKPDsimtime(24*evalDay),
                                      nTrial        = 10,
                                      nSubj         = 10,
                                      LLOQ.PD,                  # Parasitemia LLOQ (linear scale)
                                      cureThreshold,
                                      replace       = TRUE,     # Setting for the function sample().
                                      setting       = NULL
) {
  # Simulations with (human) NLME models for PK and PD of drug to combine.
  # Interaction model based on (SCID mouse) NLME model
  #
  # There can be covariates in the PK and the PD model that are taken into account.
  # They need to be delivered by the user if they are present in the model.
  # If dose is a covariate it needs to be specified by the user in 'doseCovariate'.
  # Only one dose covariate is defined per compound, therefore, it needs to have the
  # same name in the PK and the PD model of the respective compound if applied in both models.
  #
  # Currently, no PK DDI is considered.
  # Standard models for PD DDI are considered and IC50s are set to respective EC50 values.
  #
  # PK parameters are sampled from uncertainty for each trial and for IIV within each trial.
  # PD and interaction parameters are sampled from uncertainty.

  #-----------------------------------------------------------------------------#
  # STEP 1: Define default solver setting ----
  #-----------------------------------------------------------------------------#

  # Flags & Sensitivity Parameters to Test:
  if ("FLAGsensitivity" %in% names(setting)){FLAGsensitivity = setting$FLAGsensitivity} else{FLAGsensitivity = FALSE}
  if ("FLAGuseSensEq"   %in% names(setting)){FLAGuseSensEq   = setting$FLAGuseSensEq  } else{FLAGuseSensEq   = TRUE }
  if ("sensParams"      %in% names(setting)){sensParams      = setting$sensParams     } else{sensParams      = NULL }
  if ("FLAGoutputsOnly" %in% names(setting)){FLAGoutputsOnly = setting$FLAGoutputsOnly} else{FLAGoutputsOnly = FALSE}

  # Sensitivity Parameters to Test:
  if ("opt_eventTimes"            %in% names(setting)){opt_eventTimes            = setting$opt_eventTimes           } else{opt_eventTimes            = NULL }
  if ("opt_method_stiff"          %in% names(setting)){opt_method_stiff          = setting$opt_method_stiff         } else{opt_method_stiff          = TRUE }
  if ("opt_abstol"                %in% names(setting)){opt_abstol                = setting$opt_abstol               } else{opt_abstol                = 1e-09}
  if ("opt_reltol"                %in% names(setting)){opt_reltol                = setting$opt_reltol               } else{opt_reltol                = 1e-06}
  if ("opt_minstep"               %in% names(setting)){opt_minstep               = setting$opt_minstep              } else{opt_minstep               = 0    }
  if ("opt_maxstep"               %in% names(setting)){opt_maxstep               = setting$opt_maxstep              } else{opt_maxstep               = 0    }
  if ("opt_initstep"              %in% names(setting)){opt_initstep              = setting$opt_initstep             } else{opt_initstep              = 0    }
  if ("opt_maxnumsteps"           %in% names(setting)){opt_maxnumsteps           = setting$opt_maxnumsteps          } else{opt_maxnumsteps           = 1e+05}
  if ("opt_maxerrtestfails"       %in% names(setting)){opt_maxerrtestfails       = setting$opt_maxerrtestfails      } else{opt_maxerrtestfails       = 50   }
  if ("opt_maxorder_stiff"        %in% names(setting)){opt_maxorder_stiff        = setting$opt_maxorder_stiff       } else{opt_maxorder_stiff        = 5    }
  if ("opt_maxorder_nonstiff"     %in% names(setting)){opt_maxorder_nonstiff     = setting$opt_maxorder_nonstiff    } else{opt_maxorder_nonstiff     = 12   }
  if ("opt_maxconvfails"          %in% names(setting)){opt_maxconvfails          = setting$opt_maxconvfails         } else{opt_maxconvfails          = 10   }
  if ("opt_maxnonlineariter"      %in% names(setting)){opt_maxnonlineariter      = setting$opt_maxnonlineariter     } else{opt_maxnonlineariter      = 3    }
  if ("opt_usesymjac"             %in% names(setting)){opt_usesymjac             = setting$opt_usesymjac            } else{opt_usesymjac             = TRUE }
  if ("opt_sens_simultaneous"     %in% names(setting)){opt_sens_simultaneous     = setting$opt_sens_simultaneous    } else{opt_sens_simultaneous     = FALSE}
  if ("opt_sens_errcon"           %in% names(setting)){opt_sens_errcon           = setting$opt_sens_errcon          } else{opt_sens_errcon           = FALSE}
  if ("opt_sens_maxnonlineariter" %in% names(setting)){opt_sens_maxnonlineariter = setting$opt_sens_maxnonlineariter} else{opt_sens_maxnonlineariter = 3    }

  # Verbose
  if ("verbose" %in% names(setting)){verbose = setting$verbose } else{verbose = FALSE}


  #-----------------------------------------------------------------------------#
  # STEP 2: Preparations ----
  #-----------------------------------------------------------------------------#

  # Number of dose groups to simulate:
  nGroups <- length(TreatmentGroups)


  #-----------------------------------------------------------------------------#
  # STEP 3: Handling of models ----
  #-----------------------------------------------------------------------------#

  # Get model results:
  #   NOTE if PKmodelFolders is a function to sample from PKres and/or
  #   PDres will be NULL and no covariate wil be accounted for.

  #   PK:
  PKres <- lapply(PKmodelFolders, function(x){
    if (is.character(x) && is_IQRnlmeProject(x)){
      #out <- getResults_IQRnlmeProject(x)
      out <- tryCatch(
        {
          out <- getResults_IQRnlmeProjectMulti(as_IQRnlmeProjectMulti(x))[[1]]
        },
        error = function(cond){
          warning(paste0("The project ", x, " is from an old IQRtools version. Not all options are available."))
          print(cond)
          out <- NULL
        })
    } else if (is.function(x)){
      out <- NULL
    } else{
      stop("'PKmodelFolders' should be a list of IQRnlmeProjects and/or funcitons to sample from.")
    }
    return(out)})

  #   PD
  PDres <- lapply(PDmodelFolders, function(x){
    if (is.character(x) && is_IQRnlmeProject(x)){
      #out <- getResults_IQRnlmeProject(x)
      out <- tryCatch(
        {
          out <- getResults_IQRnlmeProjectMulti(as_IQRnlmeProjectMulti(x))[[1]]
        },
        error = function(cond){
          warning(paste0("The project ", x, " is from an old IQRtools version. Not all options are available."))
          print(cond)
          out <- NULL
        })
    } else if (is.function(x)){
      out <- NULL
    } else{
      stop("'PDmodelFolders' should be a list of IQRnlmeProjects and/or funcitons to sample from.")
    }
    return(out)})

  # Get PKPD model:
  if (is_IQRmodel(ComboModel)) model <- ComboModel else model <- IQRmodel(ComboModel)


  #-----------------------------------------------------------------------------#
  # STEP 4-a: PKPD parameter sampling ----
  #-----------------------------------------------------------------------------#
  # In this section preliminary event data (combination of dose and individual parameter information) sets
  # are created since PKPD parameter may depend on dose

  cat("\nSampling PK and PD parameters ...")


  # ~~~~~~~~~~~~~~~~~~~~~
  # Covariate's handling

  # Check Covariates for each Compound:
  covUsedPK <- NULL
  covUsedPD <- NULL
  for (k_cpd in 1:2) {
    # Check PK model covariates:
    if(!is.null(PKres[[k_cpd]])){
      covUsedPK <- unique(unlist(sapply(PKres[[k_cpd]]$additional$covariates,
                                        function(x) sapply(x, function(xx) xx$covariates))))
    }

    # Check PD model covariates
    if(!is.null(PDres[[k_cpd]])){
      covUsedPD <- unique(unlist(sapply(PDres[[k_cpd]]$additional$covariates,
                                        function(x) sapply(x, function(xx) xx$covariates))))
    }
  }

  # Generate Covariate Flags:
  #   PK
  if (length(covUsedPK)==0) {
    FLAGcovPK <- FALSE
  } else {
    FLAGcovPK <- TRUE
    if (!all(covUsedPK %in% c(names(covariates), doseCovariate[[k_cpd]]))) { # case a covariate not supplied by user
      stop(paste0("Please give values to sample from for the following PK model covariates:\n", paste0(covUsedPK, collapse = ", ")))
    }
  }
  #   PD
  if (length(covUsedPD)==0) {
    FLAGcovPD <- FALSE
  } else {
    FLAGcovPD <- TRUE
    if (!all(covUsedPD %in% c(names(covariates), doseCovariate[[k_cpd]]))) { # case a covariate not supplied by user
      stop(paste0("Please give values to sample from for the following PD model covariates:\n", paste0(covUsedPD, collapse = ", ")))
    }
  }


  # ~~~~~~~~~~~~~~~~~~~~
  # Parameters sampling

  # NOTE:
  # Parameters need to be sampled per dose level as dose may be a covariate:

  # Loop over groups:
  preEventData <- data.frame()
  abs0inputs   <- abs0Tk0param <- NULL
  PKparameters <- PDparameters <- data.frame()
  covSample    <- data.frame()
  for (k_gr in 1:nGroups) {

    # Loop over trials:
    PKparameters <- PDparameters <- data.frame()
    for (k_Trial in 1:nTrial) {

      # Sample covariates:
      covSample_k <- data.frame(ID = 1:nSubj)
      for (cov_k in setdiff(union(covUsedPK,covUsedPD), doseCovariate[[k_cpd]])) {
        # If 'covariates' is a data frame or a list of numerical vector
        if (is.numeric(covariates[[cov_k]])){
          covSample_k[[cov_k]] <- sample(covariates[[cov_k]], nSubj, replace = replace)

          # if 'covariates' is a list of functions to sample from
        }else if (is.function(covariates[[cov_k]])){
          covSample_k[[cov_k]] <- covariates[[cov_k]](nSubj)

        } else{
          stop(paste0("'covariates[[",  cov_k, "]]' should be a numerical vector or a function."))
        }
      }

      # Sample PK & PD parameters for each parameters:
      PKparameters_cpd <- PDparameters_cpd <- data.frame(matrix(NA, nrow = 1, ncol = 0))
      for (k_cpd in 1:2) {
        # Get dose:
        Dose_k <- TreatmentGroups[[k_gr]][[k_cpd]]$dose

        # Add dose to covariates:
        covSample_k[[paste0(doseCovariate[[k_cpd]], k_cpd)]] <- Dose_k
        covSample_k[[doseCovariate[[k_cpd]]]]                <- Dose_k

        # Sample PK parameters:
        capture.output(
          if (is.character(PKmodelFolders[[k_cpd]]) && is_IQRnlmeProject(PKmodelFolders[[k_cpd]])){
            samplePK_k <- sample_IQRnlmeProject(PKmodelFolders[[k_cpd]], Nsamples = nSubj, FLAG_SAMPLE = 1, covariates = covSample_k)$parameterValuesIndividual
          } else{
            samplePK_k <- PKmodelFolders[[k_cpd]](nSubj)
          }
          , file = "tmp.txt")
        names(samplePK_k) <- paste0(names(samplePK_k),"x",k_cpd)
        PKparameters_cpd  <- cbind(PKparameters_cpd, samplePK_k)

        # Sample PD parameters:
        capture.output(
          if (is.character(PDmodelFolders[[k_cpd]]) && is_IQRnlmeProject(PDmodelFolders[[k_cpd]])){
            samplePD_k <- sample_IQRnlmeProject(PDmodelFolders[[k_cpd]], Nsamples = nSubj, FLAG_SAMPLE = 4, covariates = covSample_k)$parameterValuesPopulation
          } else{
            samplePD_k <- PDmodelFolders[[k_cpd]](nSubj)
          }
          , file = "tmp.txt")
        names(samplePD_k) <- paste0(names(samplePD_k),"x",k_cpd)
        PDparameters_cpd  <- cbind(PDparameters_cpd, samplePD_k)
      }

      # Concatenate the PK and PD parameters of each compound:
      PKparameters <- rbind(PKparameters, PKparameters_cpd)
      PDparameters <- rbind(PDparameters, PDparameters_cpd)

      # Save covariates:
      covSample_k$DoseID  <- k_gr
      covSample_k$TrialID <- k_Trial
      covSample_k$IndivID <- seq(1,nSubj)
      covSample <- rbind(covSample, covSample_k[,setdiff(names(covSample_k),c("DOSELEVEL"))])

    }

    # Concatenate PK and PD parameters:
    PKPDparameters <- cbind(PKparameters, PDparameters)

    # Set individual and trial identifier:
    PKPDparameters$TrialID <- rep(1:nTrial, each = nSubj)
    PKPDparameters$IndivID <- rep(1:nSubj, nTrial)

    # Create event table for dose k:
    dosing <- data.frame(DoseID = c(k_gr, k_gr),
                         ADM    = c(    1,   2),
                         AMT    = c(TreatmentGroups[[k_gr]][[1]]$dose,
                                    TreatmentGroups[[k_gr]][[2]]$dose))
    preEventDatak <- merge(dosing, PKPDparameters)
    preEventData  <- rbind(preEventData,preEventDatak)
  }

  # Create unique ID:
  preEventData$ID <- as.numeric(interaction(preEventData$IndivID, preEventData$TrialID, preEventData$DoseID), drop = TRUE)
  covSample$ID    <- as.numeric(interaction(covSample$IndivID   , covSample$TrialID   , covSample$DoseID   ), drop = TRUE)

  # Check for zero order absorption:
  #   Drug 1
  if ("Tk0x1" %in% names(preEventData)) {
    abs0inputs   <- c(abs0inputs  , 1)
    abs0Tk0param <- c(abs0Tk0param, "Tk0x1")
  }
  #   Drug 2
  if ("Tk0x2" %in% names(preEventData)) {
    abs0inputs   <- c(abs0inputs  , 2)
    abs0Tk0param <- c(abs0Tk0param, "Tk0x2")
  }

  # Complete dose information:
  doseData <- select(preEventData, ID, DoseID, TrialID, IndivID, AMT, ADM)
  doseData <- plyr::ddply(doseData, ~DoseID, function(x) {
    times    <- TreatmentGroups[[x$DoseID[1]]][[x$ADM[1]]]$time
    ndostime <- length(times)
    nids     <- dim(x)[1]
    out      <- x[rep(1:nids, each = ndostime),]
    out$TIME <- rep(times, nids)
    return(out)
  })
  doseData <- arrange(doseData, ID, TIME, ADM)

  # Generate final event data table:
  eventData <- suppressMessages(left_join(doseData, preEventData))


  # Some cleaning up:
  #   Discard baseline and error for PL and growth rates
  eventData <- select(eventData, -starts_with("PLbase"))
  eventData <- select(eventData, -starts_with("PLerr"))
  eventData <- select(eventData, -starts_with("GR"))

  cat("done\n")


  #-----------------------------------------------------------------------------#
  # STEP 4-b: Sample interaction parameters from SCID mouse ----
  #-----------------------------------------------------------------------------#
  cat("\nSampling interaction, baseline parasitemia, and growth rate ...")

  # sample interaction parameters always from uncertainty distribution
  if (is.character(InteractionModelFolder) && is_IQRnlmeProject(InteractionModelFolder)){
    DDIsample <- sample_IQRnlmeProject(InteractionModelFolder, Nsamples = nGroups*nTrial*nSubj, FLAG_SAMPLE = 2)$parameterValuesPopulation
  } else if (is.function(InteractionModelFolder)){
    DDIsample <- InteractionModelFolder(nGroups*nTrial*nSubj)
  } else{
    stop("'InteractionModelFolder' should be an IQRnlmeProjects or a funciton to sample from.")
  }
  # Extract interaction parameters
  DDIparameters <- DDIsample[,grep("Alpha|Beta", names(DDIsample))]
  # Map simulation IDs
  DDIparameters$ID <- 1:(nGroups*nTrial*nSubj)
  # Join to event data
  eventData <- suppressMessages(left_join(eventData, DDIparameters))

  # Make IC50 values equal to EC50 values
  eventData <- mutate(eventData,
                      IC50ax1 = EC50x1, IC50bx1 = EC50x1,
                      IC50ax2 = EC50x2, IC50bx2 = EC50x2)


  #-----------------------------------------------------------------------------#
  # STEP 4-c: Sample baseline parasitemia ----
  #-----------------------------------------------------------------------------#

  # Sample baselines from the sample provided:
  if (is.data.frame(PbaseSample)){
    PLbaseParameters <- data.frame(ID     = 1:(nGroups*nTrial*nSubj),
                                   PLbase = sample(log(PbaseSample$GR), nGroups*nTrial*nSubj, replace=replace))
  } else if (is.numeric(PbaseSample)){
    PLbaseParameters <- data.frame(ID     = 1:(nGroups*nTrial*nSubj),
                                   PLbase = sample(log(PbaseSample), nGroups*nTrial*nSubj, replace=replace))
  }else if (is.function(PbaseSample)){
    PLbaseParameters <- data.frame(ID     = 1:(nGroups*nTrial*nSubj),
                                   PLbase = log(PbaseSample(nGroups*nTrial*nSubj)))
  } else{
    stop("'PLbaseParameters' should be a data frame, a numerical vector or a function.")
  }

  # Join to event data:
  eventData <- suppressMessages(left_join(eventData, PLbaseParameters))


  #-----------------------------------------------------------------------------#
  # STEP 4-d: Sample growth parasitemia ----
  #-----------------------------------------------------------------------------#

  # Sample growth rates from the sample provided:
  if (is.data.frame(GRsample)){
    GRparameters <- data.frame(ID = 1:(nGroups*nTrial*nSubj),
                               GR = sample(GRsample$GR, nGroups*nTrial*nSubj, replace=replace))
  } else if (is.numeric(GRsample)){
    GRparameters <- data.frame(ID = 1:(nGroups*nTrial*nSubj),
                               GR = sample(GRsample, nGroups*nTrial*nSubj, replace=replace))
  }else if (is.function(GRsample)){
    GRparameters <- data.frame(ID = 1:(nGroups*nTrial*nSubj),
                               GR = GRsample(nGroups*nTrial*nSubj))
  } else{
    stop("'GRsample' should be a data frame, a numerical vector or a function.")
  }

  # Join to event data:
  eventData <- suppressMessages(left_join(eventData, GRparameters))

  cat("done\n")


  #-----------------------------------------------------------------------------#
  # STEP 5: Simulations ----
  #-----------------------------------------------------------------------------#

  # Create input event table:
  cat("\nPreparing simulations ...")
  eventTable <- IQReventTable(eventData, regression=setdiff(names(eventData), names(doseData)), abs0inputs=abs0inputs, abs0Tk0param=abs0Tk0param)
  cat("done\n")

  # Add Evaluation day into simtime in case it is missing:
  simtime <- sort(unique(c(simtime, 24*evalDay)))

  # Do simulations:
  cat("\nSimulating all treatment groups, trials, and subjects ...")
  simPKPD <- sim_IQRmodel(model,
                          simtime                   = simtime,
                          eventTable                = eventTable,
                          FLAGsensitivity           = FLAGsensitivity,
                          FLAGuseSensEq             = FLAGuseSensEq,
                          sensParams                = sensParams,
                          FLAGoutputsOnly           = FLAGoutputsOnly,
                          opt_eventTimes            = opt_eventTimes,
                          opt_method_stiff          = opt_method_stiff,
                          opt_abstol                = opt_abstol,
                          opt_reltol                = opt_reltol,
                          opt_minstep               = opt_minstep,
                          opt_maxstep               = opt_maxstep,
                          opt_initstep              = opt_initstep,
                          opt_maxnumsteps           = opt_maxnumsteps,
                          opt_maxerrtestfails       = opt_maxerrtestfails,
                          opt_maxorder_stiff        = opt_maxorder_stiff,
                          opt_maxorder_nonstiff     = opt_maxorder_nonstiff,
                          opt_maxconvfails          = opt_maxconvfails,
                          opt_maxnonlineariter      = opt_maxnonlineariter,
                          opt_usesymjac             = opt_usesymjac,
                          opt_sens_simultaneous     = opt_sens_simultaneous,
                          opt_sens_errcon           = opt_sens_errcon,
                          opt_sens_maxnonlineariter = opt_sens_maxnonlineariter,
                          verbose                   = verbose)
  cat("done\n")

  # Add IDs:
  simPKPD <- left_join(simPKPD, unique(select(doseData, ID, DoseID, TrialID, IndivID)))

  # Convert parasitemia to linear scale:
  simPKPD <- mutate(simPKPD, P = exp(PL))


  #-----------------------------------------------------------------------------#
  # STEP 6: Derive treatment success parameters ----
  #-----------------------------------------------------------------------------#

  # Success without threshold:
  successFun <- function(TIME,P){
    as.numeric(P[TIME==24*evalDay] < LLOQ.PD)
  }

  # Success with threshold:
  successCureFun <- function(TIME, P){
    as.numeric(P[TIME==24*evalDay] < LLOQ.PD | min(P[TIME<=24*evalDay]) < cureThreshold)
  }

  # Total PRR:
  PRRtotFun <- function(TIME, P){
    as.numeric(get_PRRtot(dataSim = data.frame(TIME        = TIME,
                                               Parasitemia = P,
                                               stringsAsFactors = FALSE),
                          paraCOL = "Parasitemia",
                          Plog    = FALSE))
  }

  # Summarize
  simSuccess <- summarize(group_by(simPKPD, ID, DoseID, TrialID, IndivID),
                          SUCCESS      = successFun(TIME, P),
                          SUCCESS_CURE = successCureFun(TIME, P),
                          PRRtot       = PRRtotFun(TIME, P))


  #-----------------------------------------------------------------------------#
  # STEP 7-a: Summarize timecourses across all simulations per dose group ----
  #-----------------------------------------------------------------------------#
  cat("\nSummarising simulation results ...")

  selectVariables   <- c("Ccx1", "Ccx2", "Kkillx1", "Kkillx2", "Kkill", "P") # , "Effx1", "Effx2"
  simPKPDselect     <- select(simPKPD, one_of(c("ID", "IndivID", "TrialID", "DoseID", "TIME", selectVariables)))
  simPKPDselect     <- tidyr::gather(simPKPDselect, "Variable", "Value", selectVariables)
  timeCourseSummary <- summarise(group_by(simPKPDselect, DoseID, TIME, Variable),
                                 median = quantile(Value, probs = 0.50),
                                 q05    = quantile(Value, probs = 0.05),
                                 q95    = quantile(Value, probs = 0.95))
  timeCourseSummary <- mutate(timeCourseSummary,
                              Rel2Compound = ifelse(grepl("x1$", Variable),"Compound1", "both"))
  timeCourseSummary <- mutate(timeCourseSummary,
                              Rel2Compound = ifelse(grepl("x2$", Variable), "Compound2", Rel2Compound))
  timeCourseSummary <- mutate(timeCourseSummary,
                              Variable = gsub("x[[:digit:]]{1}$", "", Variable))


  #-----------------------------------------------------------------------------#
  # STEP 7-b: Determine ACPR per dose group ----
  #-----------------------------------------------------------------------------#

  # Determine ACPR per trial:
  selectVariables  <- c("SUCCESS", "SUCCESS_CURE")
  simSuccessSelect <- select(simSuccess, one_of(c("ID", "IndivID", "TrialID", "DoseID", selectVariables)))
  simSuccessSelect <- tidyr::gather(simSuccessSelect, "Variable", "Value", selectVariables)
  ACPRperTrial     <- summarize(group_by(simSuccessSelect, DoseID, TrialID, Variable),
                                ACPR = mean(Value))
  ACPRstat         <- summarize(group_by(ACPRperTrial, DoseID, Variable),
                                mean   = mean(ACPR)*100,
                                median = quantile(ACPR, 0.50)*100,
                                q05    = quantile(ACPR, 0.05)*100,
                                q95    = quantile(ACPR, 0.95)*100)


  #-----------------------------------------------------------------------------#
  # STEP 7-c: Determine total PRR per dose group ----
  #-----------------------------------------------------------------------------#
  PRRtotalSummary <- summarise(group_by(simSuccess, DoseID),
                               mean   = mean(PRRtot),
                               median = quantile(PRRtot, 0.50),
                               q05    = quantile(PRRtot, 0.05),
                               q95    = quantile(PRRtot, 0.95))
  cat("done\n")


  #-----------------------------------------------------------------------------#
  # STEP 8: Dose annotation ----
  #-----------------------------------------------------------------------------#

  # Get treatment group names from input list:
  doseGroups        <- data.frame(DoseID = 1:nGroups, trtname = names(TreatmentGroups))
  timeCourseSummary <- dplyr::left_join(timeCourseSummary, doseGroups)
  ACPRstat          <- dplyr::left_join(ACPRstat, doseGroups)
  PRRtotalSummary   <- dplyr::left_join(PRRtotalSummary, doseGroups)


  #-----------------------------------------------------------------------------#
  # STEP 9: Return simulated summaries and stats ----
  #-----------------------------------------------------------------------------#
  return(list(simPKPD           = simPKPD,
              eventTable        = eventTable,
              Covariates        = covSample,
              timeCourseSummary = timeCourseSummary,
              ACPRstat          = ACPRstat,
              PRRtotalSummary   = PRRtotalSummary))
}
#' simulate_PKPDseparate
#'
#' @description
#' @param Doses
#' @param Ndoses
#' @param PKmodelFolder
#' @param PDmodelFolder
#' @param PKPDmodelFile
#' @param filename Default: \code{NULL}
#' @param EC50adj Default: 1
#' @param DOSEcovariate Default: \code{NULL}
#' @param covariates Default: \code{NULL}
#' @param simtime Default: 0:800
#' @param Npop Default: 10
#' @param Nind Default: 10
#' @param FLAGsamplePK Default: 1
#' @param FLAGreturnObject Default: FALSE
#' @param LLOQ.PK Default: \code{NULL}
#' @param LLOQ.PD Default: \code{NULL}
#' @param cureThreshold Default: \code{NULL}
#' @param PLbaseSample Default: \code{NULL}
#' @param setting Default: \code{NULL}
#' @return
#' @export
#' @author Anne Kümmel (IntiQuan), Mohammed H. Cherkaoui (MMV)
#' @family Simulations
#' @importFrom plyr ddply
#' @importFrom dplyr left_join mutate
simulate_PKPDseparate <- function(
  Doses,
  Ndoses,
  PKmodelFolder,
  PDmodelFolder,
  PKPDmodelFile,
  filename = NULL,
  EC50adj = 1,           # adjustment factor of EC50 value
  DOSEcovariate = NULL,  # indicate name for the dose covariate
  covariates = NULL,     # named list of covariate values to sample from
  simtime = 0:800,
  Npop = 10,
  Nind = 10,
  FLAGsamplePK = 1,
  FLAGreturnObject = FALSE,
  LLOQ.PK = NULL,
  LLOQ.PD = NULL,
  cureThreshold = NULL,
  PLbaseSample = NULL,
  setting = NULL
) {
  # Simulations with separate NLME models for PK and PD:
  # - time courses of PK and PD
  # - time above MPC90
  #
  # It is assumed that there is not covariate in the PD model.
  # However, there can be covariates in the PK model that are taken into account.
  # They need to be delivered by the user if they are present in the model.

  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # Define default solver setting ----
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  # Flags & Sensitivity Parameters to Test:
  if ("FLAGsensitivity" %in% names(setting)){FLAGsensitivity = setting$FLAGsensitivity} else{FLAGsensitivity = FALSE}
  if ("FLAGuseSensEq"   %in% names(setting)){FLAGuseSensEq   = setting$FLAGuseSensEq  } else{FLAGuseSensEq   = TRUE }
  if ("sensParams"      %in% names(setting)){sensParams      = setting$sensParams     } else{sensParams      = NULL }
  if ("FLAGoutputsOnly" %in% names(setting)){FLAGoutputsOnly = setting$FLAGoutputsOnly} else{FLAGoutputsOnly = FALSE}

  # Sensitivity Parameters to Test:
  if ("opt_eventTimes"            %in% names(setting)){opt_eventTimes            = setting$opt_eventTimes           } else{opt_eventTimes            = NULL }
  if ("opt_method_stiff"          %in% names(setting)){opt_method_stiff          = setting$opt_method_stiff         } else{opt_method_stiff          = TRUE }
  if ("opt_abstol"                %in% names(setting)){opt_abstol                = setting$opt_abstol               } else{opt_abstol                = 1e-09}
  if ("opt_reltol"                %in% names(setting)){opt_reltol                = setting$opt_reltol               } else{opt_reltol                = 1e-06}
  if ("opt_minstep"               %in% names(setting)){opt_minstep               = setting$opt_minstep              } else{opt_minstep               = 0    }
  if ("opt_maxstep"               %in% names(setting)){opt_maxstep               = setting$opt_maxstep              } else{opt_maxstep               = 0    }
  if ("opt_initstep"              %in% names(setting)){opt_initstep              = setting$opt_initstep             } else{opt_initstep              = 0    }
  if ("opt_maxnumsteps"           %in% names(setting)){opt_maxnumsteps           = setting$opt_maxnumsteps          } else{opt_maxnumsteps           = 1e+05}
  if ("opt_maxerrtestfails"       %in% names(setting)){opt_maxerrtestfails       = setting$opt_maxerrtestfails      } else{opt_maxerrtestfails       = 50   }
  if ("opt_maxorder_stiff"        %in% names(setting)){opt_maxorder_stiff        = setting$opt_maxorder_stiff       } else{opt_maxorder_stiff        = 5    }
  if ("opt_maxorder_nonstiff"     %in% names(setting)){opt_maxorder_nonstiff     = setting$opt_maxorder_nonstiff    } else{opt_maxorder_nonstiff     = 12   }
  if ("opt_maxconvfails"          %in% names(setting)){opt_maxconvfails          = setting$opt_maxconvfails         } else{opt_maxconvfails          = 10   }
  if ("opt_maxnonlineariter"      %in% names(setting)){opt_maxnonlineariter      = setting$opt_maxnonlineariter     } else{opt_maxnonlineariter      = 3    }
  if ("opt_usesymjac"             %in% names(setting)){opt_usesymjac             = setting$opt_usesymjac            } else{opt_usesymjac             = TRUE }
  if ("opt_sens_simultaneous"     %in% names(setting)){opt_sens_simultaneous     = setting$opt_sens_simultaneous    } else{opt_sens_simultaneous     = FALSE}
  if ("opt_sens_errcon"           %in% names(setting)){opt_sens_errcon           = setting$opt_sens_errcon          } else{opt_sens_errcon           = FALSE}
  if ("opt_sens_maxnonlineariter" %in% names(setting)){opt_sens_maxnonlineariter = setting$opt_sens_maxnonlineariter} else{opt_sens_maxnonlineariter = 3    }

  # Verbose
  if ("verbose" %in% names(setting)){verbose = setting$verbose } else{verbose = FALSE}


  # ------------------------------------------- #
  # Preparations ----

  # Number of dose groups to simulate
  NdosLev <- length(Doses)

  # ------------------------------------------- #
  # Handling of models ----

  # Get model results
  PKres <- getResults_IQRnlmeProjectMulti(as_IQRnlmeProjectMulti(PKmodelFolder))[[1]]
  PDres <- getResults_IQRnlmeProjectMulti(as_IQRnlmeProjectMulti(PDmodelFolder))[[1]]

  # Check PK model covariates
  covUsed <- PKres$projectHeader$COVARIATESUSED
  if (length(covUsed) == 1 & covUsed[1] == "") {
    FLAGcovPK <- FALSE
  } else {
    FLAGcovPK <- TRUE
    if (!all(covUsed %in% c(names(covariates), DOSEcovariate))) { # case a covariate not supplied by user
      stop(paste0("Please give values to sample from for the following PK model covariates:\n", paste0(covUsed, collapse = ", ")))
    }
  }

  # Get PKPD model
  modelPKPD <- IQRmodel(PKPDmodelFile)

  # ------------------------------------------- #
  # Parameter sampling ----
  if (is.null(DOSEcovariate)) { # Parameters can be sampled once for all doses

    # Sample PK parameters
    PKparameters <- PDparameters <- data.frame()
    for (k in 1:Npop) {
      if (FLAGcovPK) {
        covSample <- data.frame(ID = 1:Nind)
        for (covk in setdiff(covUsed, DOSEcovariate)) {
          covSample[[covk]] <- sample(covariates[[covk]], Nind, replace = TRUE)
        }
        samplek <- sample_IQRnlmeProject(PKmodelFolder, Nsamples = Nind, FLAG_SAMPLE = FLAGsamplePK, covariates = covSample)
        if (!is.null(samplek$parameterValuesIndividual)) samplek <- samplek$parameterValuesIndividual else samplek <- samplek$parameterValuesPopulation
        PKparameters <- rbind(PKparameters, samplek)
      } else {
        samplek <- sample_IQRnlmeProject(PKmodelFolder, Nsamples = Nind, FLAG_SAMPLE = FLAGsamplePK, covariates = NULL)
        if (!is.null(samplek$parameterValuesIndividual)) samplek <- samplek$parameterValuesIndividual else samplek <- samplek$parameterValuesPopulation
        PKparameters <- rbind(PKparameters, samplek)
      }
    }
    PKparameters$pID <- 1:(Npop*Nind)

    # Sample PD parameters and adjust with given factor
    PDparameters <- sample_IQRnlmeProject(PDmodelFolder, Nsamples = Npop*Nind, FLAG_SAMPLE = 2)$parameterValuesPopulation
    PDparameters[["EC50"]] <- PDparameters[["EC50"]] * EC50adj
    if (!is.null(PLbaseSample))
      PDparameters$PLbase <- sample(PLbaseSample, Npop*Nind)

    # Concatenate PK and PD parameters
    PKPDparameters <- cbind(PKparameters, PDparameters)

    # Create event table
    doseGroups <- data.frame(dID = 1:NdosLev, Dose = DoseLevels, Ndoses = Ndoses)
    dosing <- plyr::ddply(doseGroups, ~dID, function(x) {
      data.frame(
        dID  = x$dID,
        TIME = seq(0,by=24,length.out = x$Ndoses),
        ADM  = 1,
        AMT  = rep(x$Dose, each=x$Ndoses),
        TINF = 0
      )
    })
    eventData <- merge(dosing, PKPDparameters)
    eventData$ID <- as.numeric(interaction(eventData$dID, eventData$pID), drop = TRUE)

  } else {  # Parameters need to be sampled per dose level

    # Sample PK parameters for dose k
    eventData <- data.frame()
    for (kdos in Doses) {

      PKparameters <- data.frame()
      for (k in 1:Npop) {
        covSample <- data.frame(ID = 1:Nind)
        for (covk in setdiff(covUsed, DOSEcovariate)) {
          covSample[[covk]] <- sample(covariates[[covk]], Nind, replace = TRUE)
        }
        covSample[[DOSEcovariate]] <- kdos
        samplek <- sample_IQRnlmeProject(PKmodelFolder, Nsamples = Nind, FLAG_SAMPLE = 1, covariates = covSample)$parameterValuesIndividual
        PKparameters <- rbind(PKparameters, samplek)
      }
      PKparameters$pID <- 1:(Npop*Nind)

      # Sample PD parameters and adjust with given factor
      PDparameters <- sample_IQRnlmeProject(PDmodelFolder, Nsamples = Npop*Nind, FLAG_SAMPLE = 2)$parameterValuesPopulation
      PDparameters[["EC50"]] <- PDparameters[["EC50"]] * EC50adj

      # Concatenate PK and PD parameters
      PKPDparameters <- cbind(PKparameters, PDparameters)

      # Create event table for dose k
      dtimes <- seq(0,by=24,length.out = Ndoses)
      dosing <- data.frame(dID = which(Doses == kdos), TIME = dtimes, ADM = 1, AMT = kdos, TINF = 0)
      eventDataK <- merge(dosing, PKPDparameters)
      eventData <- rbind(eventData,eventDataK)
    }
    eventData$ID <- as.numeric(interaction(eventData$dID, eventData$pID))
  }
  # Remember dosing of each ID
  dosID   <- unique(eventData[, c("ID", "dID")])


  # ------------------------------------------- #
  # Simulations ----

  # Create input event table
  eventTable <- IQReventTable(eventData, regression = setdiff(names(PKPDparameters), "pID"))

  # Do simulations
  simPKPD <- sim_IQRmodel(modelPKPD,
                          simtime                   = simtime,
                          eventTable                = eventTable,
                          FLAGsensitivity           = FLAGsensitivity,
                          FLAGuseSensEq             = FLAGuseSensEq,
                          sensParams                = sensParams,
                          FLAGoutputsOnly           = FLAGoutputsOnly,
                          opt_eventTimes            = opt_eventTimes,
                          opt_method_stiff          = opt_method_stiff,
                          opt_abstol                = opt_abstol,
                          opt_reltol                = opt_reltol,
                          opt_minstep               = opt_minstep,
                          opt_maxstep               = opt_maxstep,
                          opt_initstep              = opt_initstep,
                          opt_maxnumsteps           = opt_maxnumsteps,
                          opt_maxerrtestfails       = opt_maxerrtestfails,
                          opt_maxorder_stiff        = opt_maxorder_stiff,
                          opt_maxorder_nonstiff     = opt_maxorder_nonstiff,
                          opt_maxconvfails          = opt_maxconvfails,
                          opt_maxnonlineariter      = opt_maxnonlineariter,
                          opt_usesymjac             = opt_usesymjac,
                          opt_sens_simultaneous     = opt_sens_simultaneous,
                          opt_sens_errcon           = opt_sens_errcon,
                          opt_sens_maxnonlineariter = opt_sens_maxnonlineariter,
                          verbose                   = verbose)

  # add dosing ID (needed for summary)
  simPKPD <- dplyr::left_join(simPKPD, dosID)

  # ------------------------------------------- #
  # Derive additional simulated values ----

  # Determine time above 90percent effect
  TaboveMPC <- plyr::ddply(simPKPD, ~ID+dID, function(x) {
    idxTabove <- x$Eff > 0.9
    Tdiff     <- diff(x$TIME)
    structure(sum(Tdiff * as.numeric(idxTabove[-1])), names = "TaboveMPC")
  })

  # ------------------------------------------- #
  # Summarize results across all simulations ----

  # Determine median effect
  SummaryEff <- plyr::ddply(simPKPD, ~dID+TIME, function(x) {
    tmp <- quantile(x$Eff, probs = c(0.05, 0.5, 0.95),na.rm=TRUE)
    data.frame(Quantile=c("5th Percentile", "Median", "95th Percentile"), Value = tmp)
  })

  # Determine median PK profile
  SummaryPK <- plyr::ddply(simPKPD, ~dID+TIME, function(x) {
    tmp <- quantile(x$Cc, probs = c(0.05, 0.5, 0.95))
    data.frame(Quantile=c("5th Percentile", "Median", "95th Percentile"), Value = tmp)
  })

  # Determine median PD profile
  SummaryPD <- plyr::ddply(simPKPD, ~dID+TIME, function(x) {
    tmp <- quantile(x$OUTPUT1, probs = c(0.05, 0.5, 0.95))
    data.frame(Quantile=c("5th Percentile", "Median", "95th Percentile"), Value = tmp)
  })

  # Determine median time above MPC90
  SummaryTMPC90 <- plyr::ddply(TaboveMPC, ~dID, function(x) {
    tmp <- quantile(x$TaboveMPC, probs = c(0.05, 0.5, 0.95))
    names(tmp) <- c("lower", "median", "upper")
    as.data.frame(t(tmp))
  })

  # ------------------------------------------- #
  # Dose annotation ----

  doseGroups <- dplyr::mutate(
    doseGroups,
    DoseLabel = ifelse(Ndoses == 1, paste0(Dose, "mg"), paste0(Ndoses, "x ", Dose, "mg"))
  )
  doseGroups <- doseGroups[with(doseGroups,order(Ndoses,Dose)),]
  doseGroups$DoseLabel <- factor(doseGroups$DoseLabel, levels = doseGroups$DoseLabel)
  SummaryTMPC90 <- dplyr::left_join(SummaryTMPC90, doseGroups)
  SummaryEff <- dplyr::left_join(SummaryEff, doseGroups)
  SummaryPK <- dplyr::left_join(SummaryPK, doseGroups)
  SummaryPD <- dplyr::left_join(SummaryPD, doseGroups)

  # ------------------------------------------- #
  # Graphs ----
  PKsamplingInfo <- switch(FLAGsamplePK,
                           "0" = "Sampling from IIV for PK",
                           "1" = "Sampling from IIV and uncertainty for PK",
                           "2" = "Sampling from uncertainty for PK (covariates not considered)",
                           "3" = "Point estimates for PK",
                           "4" = "Sampling from uncertainty for PK"
  )

  timecoursePlot <- function(Summary, trans = NULL) {
    if (!is.null(trans)) {
      trans <- gsub("\\<x\\>","Value", trans)
      Summary <- dplyr::mutate(Summary,
                               Value = eval(parse(text=trans)))
    }
    MaxTime <- max(simtime)
    Dtime <- floor(MaxTime/24/5)
    IQRggplot(Summary, aes(TIME/24,Value)) +
      geom_line(aes(linetype = Quantile)) +
      scale_linetype_manual(values=c(2,2,1)) +
      facet_wrap(~DoseLabel, nrow = 1) +
      scale_x_continuous(breaks = seq(0,max(simtime), by = Dtime)) +
      labs(
        x="Time [days]",
        caption=paste0("Summary across ", Npop, " populations with ", Nind, " subjects.\n",PKsamplingInfo," and sampling from uncertainty for PD")
      ) +
      theme(legend.position = "bottom", legend.direction = "horizontal")
  }

  # Plot median PK profile time course per dose
  grPK <- timecoursePlot(SummaryPK, trans = "1000*x") +
    scale_y_log10(breaks = 10^seq(-2,4)) +
    labs(
      y="Concentration [ng/mL]"
    )
  if (!is.null(LLOQ.PK))
    grPK <- grPK +
    coord_cartesian(ylim = c(0.1*LLOQ.PK, 10*max(SummaryPK$Value*1000))) +
    geom_hline(yintercept = LLOQ.PK, linetype = 4, color = "darkorange")

  # Plot median PD profile time course per dose
  grPD <- timecoursePlot(SummaryPD, trans = "exp(x)") +
    scale_y_log10() +
    labs(
      y="Parasite Counts [%]"
    )
  if (!is.null(LLOQ.PD))
    grPD <- grPD +
    coord_cartesian(ylim = c(0.1*min(exp(SummaryPD$Value)), 10*max(exp(SummaryPD$Value)))) +
    geom_hline(yintercept = LLOQ.PD, linetype = 4, color = "darkorange")

  # Plot summary effect time course per dose
  grEff <- timecoursePlot(SummaryEff, trans = "100*x") +
    labs(
      y="Fraction of Maximum Clearance Effect [%]"
    ) +
    geom_segment(data=SummaryTMPC90,
                 aes(x = lower/24, xend = upper/24, y = 90, yend = 90),
                 color = "firebrick", size = 0.4) +
    geom_point(data=SummaryTMPC90,
               aes(x = median/24, y = 90),
               color = "firebrick", size = 1) +
    geom_text(data=SummaryTMPC90,
              aes(x = upper/24, y = 90,
                  label = paste0(round(median/24,1), " days (",round(lower/24,1),":",round(upper/24,1),")")),
              hjust = -0.05, vjust = 1.2, color = "firebrick")

  # Print to file if pathname given
  if (!is.null(filename)) {
    pageWidth  <- 2 + NdosLev*2.7
    pageHeight <- 4
    IQRoutputPDF(list(grPK, grPD, grEff), filename = filename, width = pageWidth, height = pageHeight, onefile = TRUE)
  }

  # Output
  if (FLAGreturnObject) {
    simPKPD <- dplyr::left_join(simPKPD, doseGroups)
    return(simresult = list(simulation = simPKPD, graphs = list(PK=grPK, PD=grPD, Eff=grEff)))
  }

}

#' Extract parameter names from IIV correlation name
#' Convention of IIV correlation estimate name:
#' 'corr_(par1,par2)'
#'
#' @param corrString
#'
#' @return character vector with parameter names
#'
getCorrParNames <- function(corrString) {
  namesSepComma <- gsub("corr_(", "", gsub(")$", "", corrString), fixed = TRUE)
  parnames <- IQRtools::aux_explode(namesSepComma)
  parnames
}
